<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Às Space - AI Tools (Study Assistant slice)</title>
<style>
  :root { --kbd: 0px; --accent:#0078ff; --bg:#f7f9fc; --muted:#7b8a93; --danger:#ff4d4f; }

  body {
    margin:0; padding:0; font-family: "Segoe UI", Tahoma, sans-serif; background: var(--bg); color: #111;
  }
  /* topbar */
  .topbar {
    display:flex;
    align-items:center;
    gap:12px;
    padding:12px 16px;
    position:relative;
    z-index:1000;
  }
  .left-area { display:flex; align-items:center; gap:8px; min-width:0; }
  .menu-btn{display:none;} /* placeholder */

  .site-name {
    font-weight:800;
    color:var(--accent);
    font-size:20px;
    white-space: nowrap;
  }
  .search-bar { flex:1; min-width:0; }
  .search-bar input {
    width:100%;
    padding:8px 12px;
    border-radius:20px;
    border:1px solid #d0d7dd;
    background: white;
    box-shadow: 0 2px 8px rgba(15,30,40,0.03);
    font-size:14px;
  }
  .nav-links { display:flex; gap:14px; align-items:center; }
  .nav-links a {
    color:#111; text-decoration:none; font-weight:600; padding:6px 8px; border-radius:8px;
  }
  .nav-links a:hover { color:var(--accent); background: rgba(3,100,170,0.04); }
  /* make image preview reasonably large and clear */
.att-image {
  display: block;
  max-width: 420px;    /* تعيين قياس أكبر قليلاً */
  max-height: 320px;
  width: auto;
  height: auto;
  border-radius: 10px;
  object-fit: cover;
  margin-top: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.08);
  cursor: pointer;
}

 .scroll-to-bottom-btn {
  position: absolute;
  bottom: 120px;
  right: 25px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(4px);
  border: 1px solid #eaf0f6;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #333;
  opacity: 0;
  pointer-events: none;
  transform: translateY(10px);
  transition: opacity .2s ease, transform .2s ease, background-color .3s ease, border-color .3s ease;
  z-index: 14050; /* <-- This brings the button to the front */
}
.scroll-to-bottom-btn.visible {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0);
}
/* --- START: Dark Mode Scroll Button Fix --- */
body.dark-mode .scroll-to-bottom-btn {
  background-color: rgba(42, 48, 56, 0.85); /* Dark background */
  border-color: #30363d;
  color: #e6edf3; /* Light arrow color */
}
/* --- END: Dark Mode Scroll Button Fix --- */

/* --- FINAL & COMPLETE: DYNAMIC THEME STYLES --- */

/* 1. Theme Toggle Button Styles */
.theme-toggle-btn { background: none; border: none; cursor: pointer; padding: 6px; display: flex; align-items: center; justify-content: center; margin-right: 15px; }
.theme-toggle-btn svg { width: 20px; height: 20px; stroke: #57606a; stroke-width: 2; fill: none; transition: transform 0.3s ease; }
.theme-toggle-btn .moon-icon { display: none; }
.dark-mode .theme-toggle-btn .sun-icon { display: none; }
.dark-mode .theme-toggle-btn .moon-icon { display: block; stroke: #c8ced8; }
.theme-toggle-btn:hover svg { transform: scale(1.1) rotate(15deg); }

/* 2. Page & Card General Theme Styles */
body.dark-mode { --bg:#161b22; --accent:#2f81f7; --muted:#8a939b; }
body.dark-mode, body.dark-mode .lead { color: #e6edf3; }
body.dark-mode .card { background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)), url('https://images.unsplash.com/photo-1518972559570-7cc1309f6f3b?q=80&w=1400&auto-format&fit=crop&ixlib=rb-4.0.3&s=bd14a4a2b5bf327c3b6f6e8fc4c6b3b7') center/cover no-repeat; box-shadow: 0 18px 50px rgba(0,0,0,0.25); }
body.dark-mode .card .overlay { background: linear-gradient(to top, rgba(0,0,0,0.7), rgba(0,0,0,0.2) 45%, rgba(0,0,0,0.1) 80%); }

/* 3. CHAT PANEL DARK MODE */
body.dark-mode .chat-shell { background: linear-gradient(180deg, #1f242c, #1a1e25); box-shadow: 0 30px 80px rgba(0,0,0,0.3); }
body.dark-mode .chat-header { background: linear-gradient(90deg, rgba(47,129,247,0.05), rgba(47,129,247,0.02)); border-bottom: 1px solid #30363d; }
body.dark-mode .persona-name, body.dark-mode .small, body.dark-mode .kebab-btn, body.dark-mode .back-btn { color: #e6edf3; }
body.dark-mode .persona-desc { color: #8b949e; }
body.dark-mode .messages { background: linear-gradient(180deg, rgba(31,36,44,0), rgba(31,36,44,0.4)); }
body.dark-mode .msg.assistant {
  background: transparent; /* <--- التأكد من أنها شفافة دائمًا */
  color: #e6edf3; /* الحفاظ على لون النص الفاتح */
}
body.dark-mode .msg .bubble { color: #e6edf3; }
body.dark-mode .composer { background: #161b22; border-top: 1px solid #30363d; box-shadow: 0 -6px 18px rgba(0,0,0,0.2); }
body.dark-mode .input-field { background: #21262d; color: #e6edf3; border-color: rgba(139,148,158,0.2); box-shadow: inset 0 2px 8px rgba(0,0,0,0.2); }
body.dark-mode .input-field:focus { border-color: var(--accent); box-shadow: 0 10px 30px rgba(0,100,255,0.1), inset 0 2px 10px rgba(0,0,0,0.1); }
body.dark-mode .attach-btn { background: linear-gradient(180deg, rgba(47,129,247,0.1), rgba(47,129,247,0.05)); box-shadow: 0 6px 14px rgba(0,100,255,0.08); }
body.dark-mode .attach-btn svg { stroke: #c8ced8; }
body.dark-mode .kebab-btn:hover { background: rgba(255,255,255,0.08); }
body.dark-mode .msg-actions .act-btn svg, body.dark-mode .user-actions .act-btn svg { stroke: #c8ced8; }
body.dark-mode .feedback-input { background: #21262d; color: #e6edf3; border-color: #30363d; }

/* --- START: Rotator Text Dark Mode Fix --- */
body.dark-mode .rotator {
    color: rgba(139, 148, 158, 0.7); /* لون فاتح وواضح للكلام المتغير */
}
/* --- END: Rotator Text Dark Mode Fix --- */

/* 4. MENUS & MODALS DARK MODE */
body.dark-mode .menu-dropdown, body.dark-mode .convo-item-menu, body.dark-mode .attach-panel { background: #2a3038; border-color: #30363d; box-shadow: 0 12px 40px rgba(0,0,0,0.4); }
body.dark-mode .menu-dropdown button, body.dark-mode .convo-item-menu button, body.dark-mode .attach-option { color: #e6edf3; }
body.dark-mode .menu-dropdown button:hover, body.dark-mode .convo-item-menu button:hover, body.dark-mode .attach-option:hover { background: rgba(139, 148, 158, 0.1); color: var(--accent); }
body.dark-mode .modal { background: #21262d; box-shadow: 0 16px 40px rgba(0,0,0,0.3); }
body.dark-mode .modal h3 { color: #e6edf3; }
body.dark-mode .modal p { color: #8b949e; }
body.dark-mode .btn.ghost { background: #30363d; color: #e6edf3; }
body.dark-mode .reason { border-color: #30363d; color: #e6edf3; }
body.dark-mode .reason.selected { border-color: var(--accent); background: rgba(47, 129, 247, 0.15); }
body.dark-mode .report-text, body.dark-mode .rename-input { background: #21262d; color: #e6edf3; border-color: #30363d; }
body.dark-mode .rename-input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(47, 129, 247, 0.2); }

/* 5. HAMBURGER MENU DARK MODE */
body.dark-mode .convos-btn .lines i { background: #e6edf3; }
body.dark-mode .convo-panel { background: rgba(22, 27, 34, 0.92); backdrop-filter: blur(8px); box-shadow: 0 30px 80px rgba(0,0,0,0.4); }
body.dark-mode .convo-close { color: #e6edf3; }
body.dark-mode .convo-item { background: rgba(48, 54, 61, 0.7); border-color: #30363d; }
body.dark-mode .convo-item .title { color: #e6edf3; }
body.dark-mode .convo-item .meta { color: #8b949e; }
body.dark-mode .convo-chip { background: #2a3038; color: #e6edf3; border-color: #30363d; }

/* --- START: Custom Scrollbar Styles --- */
/* Works on Chrome, Edge, and Safari */
::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}
::-webkit-scrollbar-track {
  background: transparent;
}
::-webkit-scrollbar-thumb {
  background-color: #cbd8e3;
  border-radius: 10px;
  border: 3px solid transparent;
  background-clip: content-box;
}
body.dark-mode ::-webkit-scrollbar-thumb {
  background-color: #485461;
}
/* --- END: Custom Scrollbar Styles --- */

  /* --- START: Dark Mode Icon & Font Fixes --- */
body.dark-mode .msg-actions .act-btn svg,
body.dark-mode .user-actions .act-btn svg {
    stroke: #c8ced8; /* لون فاتح للأيقونات */
}
body.dark-mode .msg .bubble {
    color: #e6edf3; /* لون نص أوضح وأكثر بياضًا */
}
/* --- END: Dark Mode Icon & Font Fixes --- */

  /* --- START: Dark Mode Code Block Icon Fix --- */
body.dark-mode .code-block-actions button svg {
    stroke: #d0d8e1; /* هذا هو السطر الذي سيصلح لون أيقونات البلوك */
}
/* --- END: Dark Mode Code Block Icon Fix --- */


/* 4. Code Block Dynamic Styles */
.msg .code-block-container {
  position: relative; margin-top: 12px; border-radius: 10px; overflow: hidden;
  transition: background-color 0.3s ease, border-color 0.3s ease;
}
.msg .code-block-header {
  display: flex; justify-content: space-between; align-items: center; padding: 8px 14px;
  font-size: 12px; font-family: 'SF Mono', 'Consolas', monospace; text-transform: uppercase;
  transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
}
.msg .code-block-actions { display: flex; gap: 8px; }
.msg .code-block-actions button {
  background: transparent; border: none; cursor: pointer; padding: 4px; border-radius: 6px;
  display: flex; align-items: center; justify-content: center;
  transition: background-color .2s ease, transform .15s ease, color 0.3s ease;
}
.msg .code-block-actions button:hover { transform: scale(1.05); }
.msg .code-block-actions button svg { width: 14px; height: 14px; }
.code-block-container pre { margin: 0; padding: 16px; overflow-x: auto; }
.code-block-container pre code.hljs { padding: 0; background: none; font-size: 14px; }

/* --- Light Mode Code Block --- */
:not(.dark-mode) .code-block-container {
  background-color: #f6f8fa; border: 1px solid #d0d7dd;
}
:not(.dark-mode) .code-block-header {
  background-color: #eef2f5; color: #57606a; border-bottom: 1px solid #d0d7dd;
}
:not(.dark-mode) .code-block-actions button { color: #57606a; }
:not(.dark-mode) .code-block-actions button:hover { background: rgba(0, 0, 0, 0.05); }
:not(.dark-mode) .code-block-container pre code.hljs { color: #24292e; }

/* --- Dark Mode Code Block --- */
.dark-mode .code-block-container {
  background-color: rgba(30, 32, 37, 0.85); border: 1px solid rgba(255, 255, 255, 0.1);
}
.dark-mode .code-block-header {
  background-color: transparent; color: #d0d8e1; border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
.dark-mode .code-block-actions button { color: #d0d8e1; }
.dark-mode .code-block-actions button:hover { background: rgba(255, 255, 255, 0.1); }
.dark-mode .code-block-container pre code.hljs { color: #e6edf3; }

/* --- END: DYNAMIC THEME STYLES --- */

  /* --- START: Collapsible Code Block Styles --- */
.code-block-container .collapse-btn {
    background: none; border: none; cursor: pointer; padding: 0; color: inherit;
    display: flex; align-items: center; justify-content: center;
}
.code-block-container .collapse-btn svg {
    width: 18px; height: 18px; transition: transform 0.3s cubic-bezier(.2,.9,.25,1);
}
.code-block-container .collapse-btn.is-open svg {
    transform: rotate(180deg);
}
.code-block-container pre {
    /* حركة ناعمة عند الطي والتوسيع */
    transition: max-height 0.4s cubic-bezier(.2,.9,.25,1), padding 0.4s ease;
    max-height: 800px; /* ارتفاع افتراضي كبير */
    position: relative;
}
.code-block-container.collapsed pre {
    max-height: 80px; /* ارتفاع صغير عند الطي (3-4 أسطر) */
    padding-bottom: 24px; /* مساحة للظل */
}
/* الظل الذي يظهر في الأسفل عند الطي */
.code-block-container.collapsed pre::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 30px;
    background: linear-gradient(to top, var(--bg, #fff) 20%, transparent);
    pointer-events: none;
}
/* --- START: Collapsible Shadow FIX --- */
.code-block-container::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 30px;
    background: linear-gradient(to top, var(--bg, #fff) 20%, transparent);
    pointer-events: none;
    opacity: 0; /* ابدأ مخفيًا */
    transition: opacity 0.3s ease;
}
body.dark-mode .code-block-container::after {
    background: linear-gradient(to top, #161b22 20%, transparent);
}
.code-block-container.collapsed::after {
    opacity: 1; /* أظهره فقط عندما يكون البلوك مطويًا */
}
/* --- END: Collapsible Shadow FIX --- */
  
  /* --- START: New Typing & Analyzing Animations --- */
.msg.typing-indicator .bubble {
  background: transparent !important;
  box-shadow: none !important;
}
.content.typing {
  display: block; padding: 6px 0; margin: 0; position: relative; min-height: 40px;
}


.barsLayer,
.analyzingLayer {
  display: flex !important;
  justify-content: flex-start !important;  /* خلي النص على اليسار */
  align-items: center;
  width: auto !important;
  min-width: 120px;
  height: 44px;
  margin-left: 0 !important; /* تأكد إنه ملزّق عاليسار */
}

.barsLayer { opacity: 1; }
.analyzingLayer { opacity: 0; }

/* لما يتحول المؤشر */
.content.to-analyzing .barsLayer { opacity: 0; }
.content.to-analyzing .analyzingLayer { opacity: 1; }

/* Bouncing Bars Styles */
.barsLayer {
  display: inline-flex; align-items: center;
}
.barsLayer .bars { display: inline-flex; align-items: flex-end; gap: 6px; height: 20px; }
.barsLayer .bar {
  width: 4px; height: 14px; background: #aab5c0; border-radius: 3px;
  transform-origin: bottom; animation: bounce 1s infinite ease-in-out;
}
body.dark-mode .barsLayer .bar { background: #6e7681; }
.barsLayer .bar:nth-child(1) { animation-delay: -0.9s; }
.barsLayer .bar:nth-child(2) { animation-delay: -0.7s; }
.barsLayer .bar:nth-child(3) { animation-delay: -0.5s; }
.barsLayer .bar:nth-child(4) { animation-delay: -0.3s; }
.barsLayer .bar:nth-child(5) { animation-delay: -0.1s; }
@keyframes bounce {
  0%, 100% { transform: scaleY(.38); opacity: .6; }
  40% { transform: scaleY(1); opacity: 1; }
  80% { transform: scaleY(.78); opacity: .85; }
}

/* Analyzing Layer Styles (Using Grid for perfect centering) */
.analyzingLayer {
  opacity: 0;
  transform: translateY(-50%) translateY(4px) scale(.98);
  display: grid;
  place-items: center; /* Center everything perfectly */
  width: 170px;
  height: 44px;
}
/* Place both text and SVG in the same grid cell to stack them */
.analyzingText, .led-svg {
  grid-column: 1 / 1;
  grid-row: 1 / 1;
}
.analyzingText {
  font-weight: 700; font-size: 14px;
  z-index: 2; /* Ensure text is on top */
  position: relative;
  background: linear-gradient(90deg, #6e7681 20%, #b0b8c0 50%, #6e7681 80%);
  background-size: 200% 100%; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
  animation: waveMoveText 2.5s linear infinite;
}
body.dark-mode .analyzingText {
  background: linear-gradient(90deg, #e6edf3 20%, #8b949e 50%, #e6edf3 80%);
  background-size: 200% 100%; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
}
@keyframes waveMoveText { to { background-position: -200% center; } }
.led-svg {
  width: 100%; height: 100%; overflow: visible; z-index: 1;
}
.led-path {
  fill: none; stroke-width: 3; stroke-linecap: round;
  filter: drop-shadow(0 0 8px rgba(0, 120, 255, 0.32));
  stroke-dasharray: 8 600;
  stroke-dashoffset: 600;
  animation: ledSweep 4s linear infinite;
}
@keyframes ledSweep {
  0%{stroke-dashoffset:var(--pathLen);opacity:0} 3%{opacity:1} 30%{stroke-dashoffset:0;opacity:1}
  45%{opacity:1} 50%{opacity:0} 100%{stroke-dashoffset:var(--pathLen);opacity:0}
}

/* Transition Classes */
.content.to-analyzing .barsLayer { opacity: 0; transform: translateY(-50%) translateY(-6px) scale(.98); }
.content.to-analyzing .analyzingLayer { opacity: 1; transform: translateY(-50%) translateY(0) scale(1); }
/* --- END: New Typing & Analyzing Animations --- */
  
  /* make image preview reasonably large and clear */
.att-image {
  display: block;
  max-width: 420px;
  max-height: 320px;
  width: auto;
  height: auto;
  border-radius: 10px;
  object-fit: cover;
  margin-top: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.08);
  cursor: pointer;
}

/* file icon extension label */
.file-icon {
  display:flex;
  align-items:center;
  justify-content:center;
  width:48px;
  height:48px;
  border-radius:8px;
  background: #f5f8fb;
  font-weight:700;
  font-size:12px;
  color:#0b2633;
}
.file-icon-ext {
  pointer-events:none;
  user-select:none;
}

  /* SIDE MENU (HAMBURGER) */
  .side-menu {
    position: fixed;
    top: 56px;
    left: 0;
    height: calc(100vh - 56px);
    width: min(50%, 420px);
    overflow:auto;
    background: rgba(255,255,255,0.86);
    backdrop-filter: blur(6px);
    box-shadow: 0 30px 80px rgba(10,30,50,0.12);
    border-radius: 0 12px 12px 0;
    padding:18px 12px;
    z-index: 99999;
    opacity: 0;
    transform: translateX(-10px);
    pointer-events: none;
    transition: opacity .32s cubic-bezier(.2,.9,.25,1), transform .32s cubic-bezier(.2,.9,.25,1);
  }
  .side-menu.visible {
    opacity: 1;
    transform: translateX(0);
    pointer-events: auto;
  }
  .side-menu a {
    display:block;
    padding:14px 12px;
    color: #111;
    text-decoration: none;
    border-radius:8px;
    font-weight:600;
  }
  .side-menu a:hover {
    color: var(--accent);
    background: rgba(3,100,170,0.04);
  }

  @media (max-width: 768px) {
    .nav-links { display:none; }
    .menu-btn { display:inline-flex; }
    .search-bar { display:none; }
    .side-menu { width: 50%; }
  }

  /* Hero section */
  .hero {
    text-align: center;
    margin-top: 50px;
    padding: 0 16px;
  }
  .hero h1 {
    font-size: 36px;
    color: #0b2633;
    margin-bottom: 12px;
    white-space: nowrap;
  }
  .hero p {
    color: #394a52;
    max-width: 720px;
    margin: 0 auto 24px auto;
    font-size: 18px;
  }
  .hero button {
    position: relative;
    overflow: hidden;
    background-color: var(--accent);
    color: white;
    border: none;
    padding: 14px 28px;
    font-size: 16px;
    border-radius: 30px;
    cursor: pointer;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
  }
  .hero button span {
    display: inline-block;
    position: relative;
    transition: transform 0.8s ease;
  }
  .hero button:hover {
    background-color: #005bb5;
    box-shadow: 0 0 12px 4px rgba(0,120,255,0.7);
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .fade-in {
    animation: fadeIn 0.6s ease forwards;
  }
  @keyframes waveMove {
    0% { background-position: 0 0; }
    100% { background-position: 200% 0; }
  }
  .color-wave {
    background: linear-gradient(90deg, var(--accent) 20%, #00aaff 40%, var(--accent) 60%);
    background-size: 200% 100%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: waveMove 3s linear infinite;
  }

  .explore { display:none; position:relative; }
  .explore-btn{ display:inline-flex; align-items:center; gap:6px; padding:8px 12px; font-weight:700; font-size:14px; border:none; border-radius:999px; cursor:pointer; background: rgba(255,255,255,0.7); backdrop-filter: blur(6px); box-shadow: 0 6px 16px rgba(0,0,0,0.08), inset 0 0 0 1px rgba(0,120,255,0.25); transition: transform .18s ease, box-shadow .25s ease, background .25s ease; color:#0b2633; }
  .explore-panel{ position:absolute; top:42px; left:12px; right:auto; width: calc(100% - 24px); max-width: 420px; background: rgba(255,255,255,0.92); backdrop-filter: blur(8px); border-radius:12px; padding:6px; box-shadow: 0 18px 36px rgba(10,30,50,0.12); transform: translateY(8px) scale(.98); opacity:0; pointer-events:none; transition: opacity .22s cubic-bezier(.2,.9,.25,1), transform .22s cubic-bezier(.2,.9,.25,1); z-index:1001; max-height: 220px; overflow-y: auto; }
  .explore-panel.open{ opacity:1; pointer-events:auto; transform: translateY(0) scale(1); }

  .section { display:none; position:relative; }
  .section-btn{ display:inline-flex; align-items:center; gap:8px; padding:8px 12px; font-weight:700; font-size:14px; border:none; border-radius:999px; cursor:pointer; background: rgba(255,255,255,0.7); backdrop-filter: blur(6px); box-shadow: 0 6px 16px rgba(0,0,0,0.08), inset 0 0 0 1px rgba(0,120,255,0.12); transition: transform .18s ease, box-shadow .25s ease, background .25s ease; color:#0b2633; }

  .section-panel{ position:absolute; top:42px; left:12px; width: calc(100% - 24px); max-width: 420px; background: rgba(255,255,255,0.92); backdrop-filter: blur(8px); border-radius:12px; padding:8px; box-shadow: 0 18px 36px rgba(10,30,50,0.16); transform: translateY(8px) scale(0.98); opacity:0; pointer-events:none; transition: opacity .22s cubic-bezier(.2,.9,.25,1), transform .22s cubic-bezier(.2,.9,.25,1); z-index: 10050; max-height: 220px; overflow-y: auto; }
  .section-panel.open{ opacity:1; pointer-events:auto; transform: translateY(0) scale(1); }
  .section-panel .section-list{ display:flex; flex-direction:column; gap:6px; padding:6px; }
  .section-item { display:flex; gap:10px; align-items:center; padding:8px 10px; border-radius:10px; text-decoration:none; color:#0b2633; transition: background .18s ease, transform .12s ease; }
  .section-thumb { width:44px; height:44px; border-radius:10px; display:flex; align-items:center; justify-content:center; background: linear-gradient(180deg, rgba(0,120,255,0.12), rgba(0,120,255,0.06)); font-size:18px; flex-shrink:0; }
  .section-meta { display:flex; flex-direction:column; }
  .section-title { font-weight:800; font-size:14px; color:#0b2633; line-height:1; }

  .mobile-hero-search { display:none; }
  @keyframes dropIn { from { opacity:0; transform: translateY(-8px); } to { opacity:1; transform: translateY(0); } }
  @media (max-width:768px){
    .mobile-hero-search{ display:block; max-width:92%; margin: 6px auto 10px; position: relative; opacity:0; }
    .mobile-hero-search.pop-in{ animation: dropIn .6s ease forwards; }
    .mobile-hero-search input{ width:100%; padding:12px 40px 12px 14px; border-radius:18px; border:1px solid #d0d7dd; background: rgba(255,255,255,0.98); box-shadow: 0 6px 18px rgba(0,120,255,0.10), inset 0 0 0 1px rgba(0,120,255,0.06); font-size:14px; outline:none; transition: box-shadow .25s ease, transform .15s ease, border-color .25s ease; }
    .mobile-hero-search input:focus{ border-color:#b7cff1; box-shadow: 0 0 0 3px rgba(0,120,255,0.15), 0 10px 24px rgba(0,120,255,0.18); transform: translateY(-1px); }
    .mobile-hero-search .icon{ position:absolute; right:12px; top:50%; transform: translateY(-50%); width:20px; height:20px; pointer-events:none; opacity:.8; }
  }

  :root{ --card-radius:16px; }
  .wrap{max-width:980px; margin:18px auto; padding:12px;}
  header.appbar{display:flex; align-items:center; gap:12px; padding:10px 6px;}
  .site-name{font-weight:800; color:var(--accent); font-size:20px;}
  .lead{color:var(--muted); margin:6px 0 18px 0; font-size:14px;}

  .sections-grid{display:flex; flex-direction:column; gap:20px; align-items:center;}
  .card {
    width: min(420px, 94%);
    height: calc(85vh - 120px);
    max-height:760px;
    border-radius: var(--card-radius);
    overflow:hidden;
    position:relative;
    background: linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.06)), url('https://images.unsplash.com/photo-1518972559570-7cc1309f6f3b?q=80&w=1400&auto=format&fit=crop&ixlib=rb-4.0.3&s=bd14a4a2b5bf327c3b6f6e8fc4c6b3b7') center/cover no-repeat;
    box-shadow: 0 18px 50px rgba(6,30,60,0.12);
    display:flex;
    flex-direction:column;
    transition: transform .18s ease, box-shadow .18s ease;
    transform-origin: center top;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* Hover scale + soft shadow (task 2) — only on devices that support hover (PC) */
  @media (hover: hover) and (pointer: fine) {
    .card:hover {
      transform: scale(1.03);
      box-shadow: 0 30px 80px rgba(6,30,60,0.18);
    }
  }

  /* Animated gradient overlay inside the card (task 3) */
  .card::before{
    content: '';
    position: absolute;
    inset: 0;
    z-index: 0; /* behind .overlay which will be z-index:1 */
    pointer-events: none;
    background: linear-gradient(90deg, rgba(0,120,255,0.12), rgba(0,170,255,0.10), rgba(0,95,200,0.12));
    background-size: 300% 300%;
    opacity: 0.24;
    animation: cardGradientShift 20s linear infinite;
    mix-blend-mode: overlay;
  }
  @keyframes cardGradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }
  /* Disable gradient animation on small screens (mobile) to save performance */
  @media (max-width: 768px) {
    .card::before { display: none; animation: none; opacity: 0; }
  }

  .card .overlay{
    flex:1; display:flex; flex-direction:column; justify-content:space-between; padding:20px;
    background: linear-gradient(to top, rgba(0,0,0,0.45), rgba(0,0,0,0.12) 45%, rgba(0,0,0,0.03) 80%);
    color: #fff;
    position:relative;
    z-index:1; /* ensure overlay content is above animated gradient */
  }

  .card h3{margin:0; font-size:22px; font-weight:800; text-shadow:0 4px 18px rgba(0,0,0,0.35);}
  .card p{margin:8px 0 0; font-size:15px; color:rgba(255,255,255,0.95);}
  .card .meta-row{display:flex; justify-content:space-between; align-items:end; gap:10px;}
  .chat-btn{
    background: linear-gradient(90deg,var(--accent),#00aaff);
    border:none; color:white; padding:12px 16px; font-weight:800; border-radius:999px;
    box-shadow: 0 8px 24px rgba(0,120,255,0.18);
    cursor:pointer; transition: transform .18s ease, box-shadow .18s ease, opacity .12s;
  }
  .chat-btn:active{ transform:translateY(1px) scale(.997); }

  /* CHAT PANEL */
  .chat-panel{
    position:fixed; inset:0; z-index:11000; display:flex; flex-direction:column;
    padding:12px; background:linear-gradient(180deg, rgba(12,18,24,0.42), rgba(12,18,24,0.55));
    backdrop-filter: blur(8px) saturate(1.02);
    opacity:0; 
    pointer-events:none;
    transform: translateY(6px);
    will-change: opacity, transform;
    visibility: hidden;
    transition: opacity .28s cubic-bezier(.2,.9,.25,1), transform .28s cubic-bezier(.2,.9,.25,1), visibility 0s .3s;
    align-items: center;
    justify-content: flex-end;
  }
  .chat-panel.show{ 
    opacity:1; 
    pointer-events:auto; 
    transform: translateY(0);
    visibility: visible;
    transition: opacity .28s cubic-bezier(.2,.9,.25,1), transform .28s cubic-bezier(.2,.9,.25,1), visibility 0s;
  }

  .chat-shell{
    width: min(950px, 98%);
    max-width:970px;
    height: calc(92vh);
    background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(255,255,255,0.96));
    border-radius:16px; overflow:hidden; box-shadow: 0 30px 80px rgba(6,30,60,0.18);
    display:flex; flex-direction:column;
    position:relative;
    margin: 0 0 20px 0;
  }
  @media (min-width: 1100px) {
    .chat-shell { width: 75vw; max-width: 1200px; height: calc(86vh); }
  }

  /* WELCOME BANNER (task 1) — now in English + fade in/out */
  .welcome-banner{
    position: absolute;
    left: 50%;
    top: 24%;
    transform: translate(-50%, -6%);
    z-index: 1200;
    max-width: 86%;
    text-align: center;
    font-weight: 800;
    line-height: 1.08;
    font-size: 18px;
    pointer-events: none;
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    background-image: linear-gradient(90deg, var(--accent), #00aaff);
    -webkit-text-fill-color: transparent;
    display: none; /* shown only when needed via JS */
    -webkit-line-clamp: 2;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    overflow: hidden;

    opacity: 0;
    transition: opacity 360ms cubic-bezier(.2,.9,.25,1), transform 360ms cubic-bezier(.2,.9,.25,1);
  }
  .welcome-banner.visible {
    display: -webkit-box; /* allow line-clamp */
    opacity: 1;
    transform: translate(-50%, 0);
  }
  .welcome-banner.hidden {
    opacity: 0;
    transform: translate(-50%, -6%);
  }
  @media (max-width:420px){
    .welcome-banner{ font-size: 15px; top:22%; }
  }

  .chat-header{display:flex; gap:12px; align-items:center; padding:12px 16px; border-bottom:1px solid #eef3f7; background: linear-gradient(90deg, rgba(0,120,255,0.02), rgba(0,170,255,0.01)); position:relative;}
  .back-btn{border: none; background:transparent; font-size:18px; cursor:pointer; padding:8px; border-radius:8px;}
  .persona-name{font-weight:800; font-size:16px; color:#0b2633;}
  .persona-desc{color:var(--muted); font-size:13px;}
  .header-spacer{flex:1}
  .small{font-size:13px; color:var(--muted); font-weight:700;}

  /* left-controls: back + convos button stacked */
  .left-controls { display:flex; flex-direction:column; gap:8px; align-items:center; margin-right:6px; }
  .convos-btn{
    width:36px; height:36px; border-radius:8px; border:none; background:transparent; display:inline-flex; align-items:center; justify-content:center; cursor:pointer;
  }
  .convos-btn .lines { display:inline-flex; flex-direction:column; gap:4px; width:18px; height:14px; align-items:center; justify-content:center; }
  .convos-btn .lines i { display:block; width:100%; height:2px; background:#0b2633; border-radius:2px; transition: transform .28s ease, opacity .28s ease; }
  .convos-btn.open .lines i:nth-child(1){ transform: translateY(6px) rotate(45deg); }
  .convos-btn.open .lines i:nth-child(2){ opacity: 0; transform: scaleX(0); }
  .convos-btn.open .lines i:nth-child(3){ transform: translateY(-6px) rotate(-45deg); }

  /* kebab menu - adjusted width + fade */
  .kebab-btn{ border:none; background:transparent; font-size:20px; cursor:pointer; padding:6px 8px; border-radius:8px; }
  .kebab-btn:hover{ background: rgba(0,0,0,0.04); }
  .menu-dropdown{
    position:absolute; right:10px; top:50px;
    min-width: 200px; /* increased slightly to fit text */
    background:#fff; border:1px solid #eef3f7; border-radius:12px;
    box-shadow:0 18px 42px rgba(6,30,60,.18); padding:6px;
    opacity:0; pointer-events:none; transform: translateY(-6px);
    transition: opacity .18s ease, transform .18s ease;
    z-index:14070;
    white-space: nowrap;
  }
  .menu-dropdown.show{ opacity:1; pointer-events:auto; transform: translateY(0); }
  .menu-dropdown button{
    width:auto; display:block; text-align:right; direction:rtl; background:transparent; border:none; padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:700; color:#0b2633;
  }
  .menu-dropdown button:hover{ background: rgba(3,100,170,.06); color:var(--accent); }

/* messages area */
  .messages{flex:1; overflow:auto; padding:18px; display:flex; flex-direction:column; gap:10px; background: linear-gradient(180deg, rgba(255,255,255,0), rgba(245,248,250,0.6)); transition: padding-bottom .12s ease;}
  .msg {
    max-width: 100%;
    padding:10px 12px;
    border-radius:12px; line-height:1.35; font-size:14px; box-shadow: 0 6px 18px rgba(6,30,60,0.04);
    opacity:0; transform: translateY(8px); transition: opacity .28s ease, transform .28s;
    word-wrap: break-word;
    position: relative;
    z-index: 1;
    will-change: transform, opacity;
  }
  .msg .bubble{
    white-space: pre-wrap;
    overflow-wrap: anywhere;
    word-break: break-word;
    hyphens: auto;
    max-width: 100%;
  }
  .msg.show{ opacity:1; transform:translateY(0); }
  /* تصميم فقاعة المستخدم الجديدة */
.msg.user {
  width: fit-content;
  align-self: flex-end;
  /* اللون الجديد: رمادي فاتح */
  background: #eef2f5; 
  /* لون نص داكن ليناسب الخلفية الفاتحة */
  color: #1f2328; 
  border-bottom-right-radius: 6px;
  z-index: 14030;
}

/* تصميم فقاعة المستخدم في الوضع الداكن */
body.dark-mode .msg.user {
  /* لون رمادي داكن للوضع المظلم */
  background: #2a3038;
  /* لون نص فاتح كالمعتاد */
  color: #e6edf3;
}
  /* Fix for user bubble width with Markdown */
.msg.user .bubble p {
  margin: 0;
  display: inline-block;
  text-align: left; /* To ensure text inside aligns correctly */
}
  .msg.assistant{ 
  align-self:flex-start; 
  background: transparent; /* <--- جعل الخلفية شفافة */
  box-shadow: none; /* <--- إزالة الظل */
  color:#0b2633; 
  border-bottom-left-radius:6px; 
  z-index: 1; 
}

  /* لا تجعل المؤشر يأخذ ستايل الفقاعة */
.msg.assistant.typing-indicator {
  background: transparent !important;
  box-shadow: none !important;
  border: none !important;
  padding: 0 !important;
  max-width: none !important;
}

/* لا يظهر معه الأزرار أو الريأكشن */
.msg.assistant.typing-indicator .msg-actions,
.msg.assistant.typing-indicator .feedback-row {
  display: none !important;
}
  /* --- START: Final Arabic Text Alignment Fix --- */
.msg .bubble[dir="rtl"] p {
    text-align: right;
}
  /* --- END: FINAL MESSAGE ALIGNMENT & STYLE FIX --- */

  /* --- START: RTL Text Alignment Helper --- */
.bubble.rtl-text {
    text-align: right;
}
/* --- END: RTL Text Alignment Helper --- */

  .msg-actions{
    display:flex; align-items:center; gap:6px; margin-top:6px; opacity:.95;
  }
  .msg-actions .act-btn{
    width:26px; height:26px; display:inline-flex; align-items:center; justify-content:center;
    border:none; background:transparent; border-radius:6px; cursor:pointer;
  }
  .msg-actions .act-btn:hover{ background: rgba(0,0,0,0.05); }
  .msg-actions .act-btn[data-active="true"]{ background: rgba(0,120,255,0.08); }
  .msg-actions .divider{ width:1px; height:14px; background:#e8eef3; margin:0 4px; }

  .act-btn[data-tip]{
    position:relative;
  }
  .act-btn[data-tip]:hover::after{
    content: attr(data-tip);
    position:absolute; bottom: calc(100% + 6px); left:50%; transform: translateX(-50%); white-space: nowrap;
    background: rgba(8,16,28,.92); color:#fff; font-size:11px; padding:4px 6px; border-radius:6px;
    box-shadow:0 8px 16px rgba(6,30,60,.2);
  }
  .feedback-row{
    margin-top:6px; display:none; flex-direction:column; gap:6px; width:100%; box-sizing:border-box;
  }
  .feedback-input{
    width:100%; padding:8px 10px; border:1px solid #e6ecf3; border-radius:8px; font-size:13px; box-sizing:border-box; max-width:100%;
  }
  .feedback-actions{ display:flex; gap:8px; justify-content:flex-end; }
  .mini-btn{
    padding:6px 10px; border:none; border-radius:8px; font-weight:700; cursor:pointer; font-size:12px;
  }
  .mini-btn.send{ background: var(--accent); color:#fff; }
  .mini-btn.cancel{ background:#f0f4f8; }

  /* --- START: Final RTL Action Icons Alignment Fix --- */
.msg.msg-rtl .msg-actions {
    justify-content: flex-end;
}
/* --- END: Final RTL Action Icons Alignment Fix --- */

  /* Attachment rendering inside messages */
  .msg .att-image {
    display:block;
    max-width: min(62vw, 420px);
    width: auto;
    height: auto;
    border-radius:12px;
    margin-top:8px;
    box-shadow: 0 12px 30px rgba(6,30,60,0.12);
    object-fit: cover;
    cursor:pointer;
  }
  .msg .file-card {
    display:flex;
    gap:10px;
    align-items:center;
    margin-top:8px;
    background:#f7fbff;
    padding:10px;
    border-radius:10px;
    border:1px solid #eaf4ff;
  }
  .file-icon {
  width: 42px;
  height: 42px;
  border-radius: 6px;
  background: #f0f2f5;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 14px;
  color: #333;
  margin-right: 8px;
}
  .file-meta { display:flex; flex-direction:column; gap:4px; }
  .file-name { font-weight:800; color:#0b2633; }
  .file-size { font-size:12px; color:var(--muted); }

  .composer{ display:flex; gap:8px; align-items:center; padding:10px 12px; border-top:1px solid #eef3f7; background: linear-gradient(180deg,#fff,#fff); position:absolute; left:0; right:0; bottom: calc(env(safe-area-inset-bottom, 0px)); box-shadow: 0 -6px 18px rgba(6,30,60,0.04); transition: bottom .12s ease; z-index: 14045; }
  .composer-inner{ display:flex; flex-wrap: wrap; gap:8px; align-items:center; width:100%; max-width:1100px; margin:0 auto; padding:0 6px; }
  .attach-wrap{ position:relative; flex-shrink:0; display:flex; align-items:center; }
  .attach-btn{
    width:44px; height:44px; display:inline-flex; align-items:center; justify-content:center; border-radius:10px; border:none;
    background: linear-gradient(180deg, rgba(0,120,255,0.06), rgba(0,120,255,0.02)); cursor:pointer; box-shadow: 0 6px 14px rgba(0,120,255,0.06);
  }
  .attach-btn svg{ width:20px; height:20px; display:block; }

  .attach-panel{
    position:absolute; bottom: calc(100% + 10px); left:0; min-width:180px; border-radius:12px;
    background: white; box-shadow: 0 22px 48px rgba(6,30,60,0.18); padding:8px; opacity:0; pointer-events:none;
    transform: translateY(8px) scale(.98); transition: transform .2s ease, opacity .2s ease;
    display:flex; flex-direction:column; gap:6px; z-index:12000;
  }
  .attach-panel.open{ opacity:1; pointer-events:auto; transform: translateY(0) scale(1); }
  .attach-option{ padding:10px 12px; border-radius:10px; font-weight:700; color:#0b2633; background:transparent; border:none; text-align:left; cursor:pointer; transition: background .15s ease, transform .12s ease;}
  .attach-option:hover{ background: rgba(3,100,170,0.06); transform: translateX(4px); color:var(--accent); }

  .input-wrap{flex:1; display:flex; gap:8px; align-items:center; min-width:0; position:relative;}
  .input-field{
    width:100%;
    padding:12px 48px 12px 14px;
    border-radius:999px;
    border:1px solid rgba(0,120,255,0.08);
    outline:none;
    font-size:14px; min-width:0;
    background: linear-gradient(180deg,#fff,#fbfdff);
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.03), 0 6px 18px rgba(0,120,255,0.03);
    transition: box-shadow .18s ease, transform .12s ease, border-color .12s ease;
    box-sizing: border-box;
    resize: none;
    overflow: auto;
    line-height: 1.4;
    min-height: 40px;
    max-height: 220px;
  }
  .input-field:focus{ box-shadow: 0 10px 30px rgba(0,120,255,0.08), inset 0 2px 10px rgba(0,0,0,0.03); border-color: rgba(0,120,255,0.22); transform: translateY(-1px); }

  /* زر الإرسال: حاوية */
.send-inside {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%) translateX(0);
  width: 36px;
  height: 36px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 999px;
  background: linear-gradient(180deg,#1f7bff,#005ee6);
  color: white;
  border: none;
  cursor: pointer;
  opacity: 0;
  pointer-events: none;
  transition: opacity .22s ease, transform .22s ease, background .22s ease;
  box-shadow: 0 8px 20px rgba(0,120,255,0.18);
  overflow: visible;
}

/* visible state */
.send-inside.visible { opacity: 1; pointer-events: auto; }

/* icon overlap: force absolute center and override any conflicting styles */
.send-inside .send-icon,
.send-inside .stop-icon {
  position: absolute !important;
  left: 50% !important;
  top: 50% !important;
  transform: translate(-50%, -50%) !important;
  width: 16px;
  height: 16px;
  display: block !important;
  pointer-events: none !important;
  transition: opacity .16s cubic-bezier(.2,.8,.2,1),
              transform .16s cubic-bezier(.2,.8,.2,1),
              background .22s ease;
}

/* arrow visuals (same as original) */
.send-inside .send-icon::before{
  content:''; position:absolute; left:50%; bottom:10%;
  transform:translateX(-50%);
  width:3px; height:9px; border-radius:2px;
  background: linear-gradient(180deg,#ffffff,#dbeeff);
}
.send-inside .send-icon::after{
  content:''; position:absolute; left:50%; top:0;
  transform:translateX(-50%) rotate(0deg);
  width:11px; height:7px;
  background: linear-gradient(180deg,#ffffff,#dbeeff);
  clip-path: polygon(50% 0, 100% 100%, 0 100%);
}

/* STOP icon: default hidden but present — make sure not to flash (opacity 0) */
.send-inside .stop-icon {
  opacity: 0;
  transform: translate(-50%, -50%) scale(.7);
  width: 12px;
  height: 12px;
  border-radius: 3px;
  background: transparent;
  box-shadow: none;
  z-index: 5;
}

/* ensure arrow sits below stop visually */
.send-inside .send-icon { z-index: 2; }

/* small feedback when pressing stop */
.send-inside.stopping{ transform: translateY(-50%) scale(.98); transition: transform .14s ease; }

/* --- PENDING: ظاهر لكن غير قابل للضغط (رمادي) --- */
.send-inside.is-pending {
  cursor: not-allowed;
  opacity: 0.98;
  pointer-events: none;
  /* keep base background subtle so the interface doesn't jump */
  background: linear-gradient(180deg,#d0d0d0,#bfbfbf);
}

/* show gray square while pending */
.send-inside.is-pending .stop-icon {
  background: linear-gradient(180deg,#bdbdbd,#e0e0e0);
  opacity: 1;
  transform: translate(-50%, -50%) scale(.95);
  box-shadow: none;
}

/* hide the arrow while pending */
.send-inside.is-pending .send-icon {
  opacity: 0;
  transform: translate(-50%, -50%) scale(.7);
}

/* --- GENERATING: أزرق + نبض + قابل للضغط --- */
.send-inside.is-generating {
  pointer-events: auto;
  cursor: pointer;
  background: linear-gradient(180deg,#1f7bff,#005ee6);
}

/* visible blue square + subtle shadow and pulse */
.send-inside.is-generating .stop-icon {
  background: linear-gradient(180deg,#1f7bff,#005ee6);
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
  box-shadow: 0 2px 10px rgba(0,110,255,0.18);
  animation: stop-pulse 1.4s ease-in-out infinite;
}

/* hide the arrow while generating */
.send-inside.is-generating .send-icon {
  opacity: 0;
  transform: translate(-50%, -50%) scale(.7);
}

/* pulse keyframes for stop icon */
@keyframes stop-pulse {
  0% { transform: translate(-50%, -50%) scale(0.98); opacity: 1; }
  50% { transform: translate(-50%, -50%) scale(1.07); opacity: 0.95; }
  100% { transform: translate(-50%, -50%) scale(0.98); opacity: 1; }
}

/* smoother transitions for both icons */
.send-inside .stop-icon,
.send-inside .send-icon {
  transition: opacity .18s ease, transform .18s ease, background .22s ease;
}

  .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

  .edit-cancel{
    display:none;
    padding:8px 10px; border-radius:10px; border:none; font-weight:700; background:#f0f4f8; cursor:pointer;
  }

  .tools{display:flex; gap:8px; align-items:center; flex-shrink:0;}
  @media (max-width:420px){
    .input-wrap{width:100%;}
  }
  
  .user-actions{
    position:absolute;
    right:8px;
    bottom:-36px;
    display:flex;
    gap:6px;
    opacity:0;
    transform: translateY(6px);
    transition: opacity .15s ease, transform .18s ease;
    z-index: 14060;
    pointer-events: none; /* MODIFICATION: Make non-clickable when invisible */
  }
  .msg.user:hover .user-actions, .msg.user.show-actions .user-actions {
    opacity:1;
    transform: translateY(0);
    pointer-events: auto; /* MODIFICATION: Make clickable when visible */
  }
  .user-actions .act-btn{
    width:28px; height:28px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; background:transparent; border:none; cursor:pointer;
  }
  .user-actions .act-btn:hover{ background: rgba(0,0,0,0.04); }

.modal-backdrop{
    position:fixed; 
    inset:0; 
    background:rgba(8,16,28,.6); 
    backdrop-filter: blur(4px);
    display:flex;
    align-items:center; 
    justify-content:center; 
    z-index:14080;
    opacity: 0;
    pointer-events: none;
    transition: opacity .25s ease;
  }
  .modal-backdrop.show{ 
    opacity: 1;
    pointer-events: auto;
  }
  .modal{
    width:min(92vw, 480px);
    background: #fff; 
    border-radius: 18px;
    box-shadow: 0 16px 40px rgba(0,0,0,0.12), 0 0 0 1px rgba(0,0,0,0.04);
    padding: 24px;
    direction:rtl;
    text-align: center;
    transform: scale(0.95) translateY(10px);
    opacity: 0;
    transition: transform .25s cubic-bezier(.2,.9,.25,1), opacity .2s ease;
  }
  .modal-backdrop.show .modal {
    transform: scale(1) translateY(0);
    opacity: 1;
  }
  .modal h3{ 
    margin:0 0 8px; 
    font-size:18px;
    font-weight: 700;
    color: #111;
  }
  .modal p{ 
    margin:0 0 20px;
    color:#55626c;
    font-size:14px; 
    line-height: 1.5;
  }
  .modal .row{ 
    display:flex; 
    gap:12px;
    justify-content:center;
    margin-top:10px; 
  }
  .btn{ 
    padding:10px 20px;
    border-radius:12px; 
    border:none; 
    cursor:pointer; 
    font-weight:700;
    font-size: 14px;
    transition: transform .15s ease, box-shadow .15s ease;
  }
  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.1);
  }
  .btn:active {
    transform: translateY(0);
    box-shadow: none;
  }
  .btn.primary{ 
    background:var(--danger, #ff4d4f); 
    color:#fff; 
  }
  .btn.ghost{ 
    background:#f0f4f8; 
    color: #333;
  }
  .rename-input {
    width: 100%;
    padding: 12px 14px;
    border-radius: 10px;
    border: 1px solid #dde4ea;
    font-size: 14px;
    margin-top: 12px;
    margin-bottom: 16px;
    box-sizing: border-box;
    transition: border-color .2s ease, box-shadow .2s ease;
    text-align: right;
  }
  .rename-input:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(0, 120, 255, 0.15);
  }
  .modal h3{ margin:0 0 8px; font-size:16px; }
  .modal p{ margin:6px 0 12px; color:#44525c; font-size:13px; }
  .modal .row{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
  .btn{ padding:8px 12px; border-radius:10px; border:none; cursor:pointer; font-weight:800; }
  .btn.primary{ background:var(--accent); color:#fff; }
  .btn.ghost{ background:#eef3f7; }
  .reason-list{ display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:8px; }
  .reason{
    border:1px solid #e6ecf3; border-radius:10px; padding:10px; cursor:pointer; user-select:none;
  }
  .reason.selected{ border-color:#90c2ff; background:#f4f9ff; }
  .report-text{ width:100%; min-height:80px; padding:10px; border:1px solid #e6ecf3; border-radius:10px; margin-top:8px; box-sizing:border-box; max-width:100%; }

  .toast{
    position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
    background:#0b2633; color:#fff; padding:10px 14px; border-radius:999px; font-size:13px;
    box-shadow:0 16px 34px rgba(6,30,60,.25); opacity:0; pointer-events:none; z-index:15000;
  }
  .toast.show{ opacity:1; transform:translate(-50%, -2px); }

  .typing .dots{ display:inline-flex; gap:6px; align-items:center; padding:6px 8px; }
  .typing .dot{ width:8px; height:8px; border-radius:50%; background:#cbd8e3; opacity:.4; transform: translateY(0); animation: tip 900ms infinite ease-in-out; }
  .typing .dot:nth-child(2){ animation-delay:120ms; }
  .typing .dot:nth-child(3){ animation-delay:240ms; }
  @keyframes tip {
    0% { transform: translateY(0); opacity:.35; }
    50% { transform: translateY(-6px); opacity:1; }
    100% { transform: translateY(0); opacity:.35; }
  }
  .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

  /* --- NEW SUGGESTION STYLES --- */
  .analyzing {
  font-size: 14px;
  font-weight: 700;
  position: relative;
  display: inline-block;
  opacity: 1;

  /* النص بلون فضي متدرج متحرك */
  background: linear-gradient(
    90deg,
    #aaa,
    #ddd,
    #aaa
  );
  background-size: 200% auto;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: gradientMove 2.5s linear infinite, pulse 1.8s ease-in-out infinite;
}

/* الخط الأزرق أسفل النص */
.analyzing::after {
  content: "";
  position: absolute;
  left: 0;
  bottom: -4px;
  width: 100%;
  height: 2px;
  background: linear-gradient(90deg, #4ac7ff, #00aaff, #4ac7ff);
  background-size: 200% auto;
  animation: underlineMove 2s linear infinite;
  border-radius: 2px;
}

/* حركة الجريدينت في النص */
@keyframes gradientMove {
  0% { background-position: 200% center; }
  100% { background-position: -200% center; }
}

/* نبض خفيف للنص */
@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

/* حركة الشريط الأزرق */
@keyframes underlineMove {
  0% { background-position: 200% center; }
  100% { background-position: -200% center; }
}
  .rotator {
    position: absolute;
    left: 14px;
    right: 76px;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
    color: rgba(11,38,51,0.48);
    font-weight:700;
    font-size:14px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    align-items: center;
    gap: 8px;
    line-height: 1;
    z-index: 10;
    opacity: 0;
  }
  .rotator .rotator-text {
    display: inline-block;
    transform: translateY(10px);
    opacity: 0;
    transition: transform .42s cubic-bezier(.2,.9,.25,1), opacity .32s ease;
    will-change: transform, opacity;
  }
  .rotator.visible {
    opacity: 1;
  }
  .rotator.visible .rotator-text {
    transform: translateY(0);
    opacity: 1;
  }
  .rotator.exit .rotator-text {
    transform: translateY(-10px);
    opacity: 0;
  }
  .rotator.hidden { opacity: 0 !important; pointer-events: none; }

  /* ===== FILE/IMAGE PREVIEW + UPLOAD PROGRESS (UPDATED) ===== */
  .file-preview-container{
    position: absolute;
    left: 12px;
    right: 12px;
    bottom: calc(100% + 8px);
    z-index: 14046;
    display:flex;
    gap:10px;
    align-items:center;
    padding: 8px 12px;
    box-sizing:border-box;
    pointer-events:auto;
  }
  .file-preview-container[aria-hidden="true"]{ display:none; }

  .thumb-outer {
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:4px;
    border-radius:12px;
    position:relative;
    overflow:visible;
    background: transparent;
    transition: transform .18s ease, opacity .24s ease;
  }

  .thumb-svg {
    position: absolute;
    inset: -4px;
    z-index: 1;
    pointer-events: none;
    overflow: visible;
    transform-origin: 50% 50%;
  }

  .file-thumb-img {
    width:56px;
    height:56px;
    border-radius:10px;
    overflow:hidden;
    background: #fff;
    box-shadow: 0 8px 20px rgba(6,30,60,0.08);
    display:inline-block;
    position:relative;
    z-index: 2;
  }
  .file-thumb-img img{ width:100%; height:100%; object-fit:cover; display:block; transform: none !important; }

  .thumb-close {
    position:absolute;
    top:-8px;
    right:-8px;
    width:22px;
    height:22px;
    border-radius:999px;
    border:none;
    background:#fff;
    box-shadow: 0 8px 18px rgba(6,30,60,0.12);
    display:inline-flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    cursor:pointer;
    font-size:12px;
    line-height:1;
    z-index: 6;
  }

  .retry-overlay {
    position:absolute;
    z-index:5;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    display:none;
    align-items:center;
    justify-content:center;
    width:44px;
    height:44px;
    border-radius:10px;
    background: rgba(255,255,255,0.95);
    box-shadow: 0 8px 22px rgba(6,30,60,0.12);
    cursor:pointer;
    color: var(--danger);
    font-weight:900;
    font-size:18px;
  }
  .thumb-outer.upload-failed .retry-overlay { display:flex; }

  .thumb-outer.upload-complete .thumb-svg { transition: opacity .6s ease; opacity:0; }
  .thumb-outer.clean-ring .thumb-svg { opacity:0 !important; transition: opacity .6s ease; }

  .file-thumb-meta {
    width:56px;
    height:56px;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:2;
    position:relative;
    border-radius:10px;
    background:#fff;
    box-shadow: 0 8px 20px rgba(6,30,60,0.06);
    padding:6px;
    text-align:center;
  }
  .file-thumb-meta .fname { font-size:11px; color:#0b2633; font-weight:800; }

  .img-lightbox {
    position: fixed;
    inset: 0;
    z-index: 16000;
    background: rgba(8,16,28,0.8);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px;
  }
  .img-lightbox .box {
    max-width: 94vw;
    max-height: 92vh;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .img-lightbox img {
    max-width: 100%;
    max-height: 100%;
    border-radius: 10px;
    box-shadow: 0 30px 80px rgba(6,30,60,0.4);
  }
  .img-lightbox .close-btn {
    position:absolute;
    top:-14px;
    right:-14px;
    width:36px;
    height:36px;
    border-radius:999px;
    background:#fff;
    border:none;
    box-shadow: 0 12px 30px rgba(6,30,60,0.2);
    font-weight:900;
    cursor:pointer;
  }

  /* small responsive tweak */
  @media (max-width:420px){
    .file-preview-container{ padding:6px; left:8px; right:8px; }
    .file-thumb-img{ width:46px; height:46px; }
    .file-thumb-meta{ width:46px; height:46px; }
    .thumb-close{ width:20px; height:20px; top:-6px; right:-6px; }
  }

  /* ===================== CONVERSATIONS SIDEBAR ===================== */
  .convo-panel{
    position: fixed;
    top: 0;
    left: 0;
    height: 100vh;
    width: min(60%, 520px);
    max-width: 72%;
    background: rgba(255,255,255,0.94);
    backdrop-filter: blur(8px);
    box-shadow: 0 30px 80px rgba(6,30,60,0.18);
    z-index: 15010;
    transform: translateX(-18px);
    opacity: 0;
    pointer-events: none;
    transition: transform .38s cubic-bezier(.2,.9,.25,1), opacity .28s ease;
    border-top-right-radius: 12px;
    border-bottom-right-radius: 12px;
    padding: 14px;
  }
  .convo-panel.open{
    transform: translateX(0);
    opacity: 1;
    pointer-events: auto;
  }
  .convo-panel-inner{ height:100%; display:flex; flex-direction:column; gap:12px; }
  .convo-panel-header{ display:flex; gap:8px; align-items:center; justify-content:space-between; }
  .convo-close{ border:none; background:transparent; font-size:22px; padding:6px 8px; border-radius:8px; cursor:pointer; }
  /* Modern, elevated "New Chat" button */
/* UPDATED: New Chat button with animations + mobile touch support */
/* زر New Chat بتصميم Gradient + أنيميشن */
.new-chat-btn {
  display:flex;
  align-items:center;
  gap:8px;
  background: linear-gradient(135deg,#6a5acd,#0078ff);
  color:white;
  border:none;
  border-radius:30px;      /* استدارة كاملة */
  padding:10px 20px;
  font-size:14px;
  font-weight:600;
  cursor:pointer;
  transition: transform .16s cubic-bezier(.2,9,25,1), 
              box-shadow .16s ease, 
              opacity .12s ease;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  will-change: transform, box-shadow;
}

/* SVG أيقونة */
.new-chat-btn .icon {
  width:16px;
  height:16px;
  transition: transform 0.28s ease;
  display:inline-block;
  vertical-align:middle;
}

/* Glow + دوران عند hover (Desktop) */
.new-chat-btn:hover {
  box-shadow: 0 0 12px #6a5acd, 0 0 28px #0078ff;
  transform: translateY(-3px);
}
.new-chat-btn:hover .icon {
  transform: rotate(90deg);
}

/* Active / Touch تأثير اهتزاز + Pulse */
.new-chat-btn:active {
  animation: nc-shake 0.34s, nc-pulse 0.34s;
  transform: translateY(-1px);
}
.new-chat-btn:active .icon {
  transform: rotate(90deg);
}

/* دعم الهواتف (.touched class من JS) */
.new-chat-btn.touched {
  animation: nc-shake 0.34s, nc-pulse 0.34s;
  box-shadow: 0 0 12px #6a5acd, 0 0 28px #0078ff;
}
.new-chat-btn.touched .icon {
  transform: rotate(90deg);
}

/* Keyframes */
@keyframes nc-shake {
  0% { transform: translateX(0); }
  25% { transform: translateX(-2px); }
  50% { transform: translateX(2px); }
  75% { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}
@keyframes nc-pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.04); }
  100% { transform: scale(1); }
}

  .convo-chips{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; padding:4px 2px; }
  .convo-chip{ padding:8px 12px; border-radius:999px; background:#eef6ff; color:#0b2633; border:1px solid #e6f2ff; font-weight:800; cursor:pointer; white-space:nowrap; }
  .convo-chip:active{ transform: translateY(1px); }

  .convo-list{ overflow:auto; padding-top:8px; display:flex; flex-direction:column; gap:10px; }
  .convo-item{ display:flex; align-items:center; justify-content:space-between; gap:8px; padding:10px; border-radius:10px; background: rgba(250,252,255,0.85); border:1px solid #eef6ff; cursor:pointer; user-select: none; /* MODIFICATION: Prevent text selection */ -webkit-user-select: none; }
  .convo-item .left{ display:flex; gap:10px; align-items:center; }
  .convo-item .title{ font-weight:800; color:#0b2633; display:inline-flex; gap:8px; align-items:center; }
  .convo-item .meta{ font-size:12px; color:var(--muted); }

  /* small screens: panel half width ensure usability */
  @media (max-width:520px){
    .convo-panel{ width: 50%; }
  }

  /* ===================== CONTEXTUAL MENU (for convo list item) ===================== */
  .convo-item-menu {
    position: fixed;
    z-index: 16010;
    background: #fff;
    border: 1px solid #e8eef3;
    border-radius: 10px;
    box-shadow: 0 12px 40px rgba(6,30,60,0.12);
    padding: 6px;
    display: none;
    min-width: 180px;
    direction: ltr;
  }
  .convo-item-menu.show { display: block; }
  .convo-item-menu button {
    display:block; width:100%; text-align:left; padding:8px 10px; border:none; background:transparent; cursor:pointer; font-weight:700; color:#0b2633; border-radius:8px;
  }
  .convo-item-menu button:hover { background: rgba(3,100,170,0.06); color: var(--accent); }
  .convo-item-menu button.soon { color: #9aa8b6; font-weight:700; cursor: default; }
  .convo-item-menu button.soon:hover { background: transparent; color: #9aa8b6; }

  /* ===================== LOCK MODAL (REMOVED) ===================== */
  /* lock UI removed per request */

</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css" />
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<link rel="stylesheet" id="highlight-theme" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/stackoverflow-light.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header class="appbar" aria-hidden="false">
  <div class="site-name">Às Space</div>
  <div class="header-spacer"></div>
  <button id="theme-toggle-btn" class="theme-toggle-btn" title="Toggle theme">
    <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
    <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
  </button>
  <div class="lead">Test: Study Assistant — demo vertical slice</div>
</header>

<main class="sections-grid" role="main" aria-label="All sections">
      <article class="card" id="studyCard" data-id="study" aria-labelledby="studyTitle" role="article">
        <div class="overlay">
          <div>
            <h3 id="studyTitle">Study Assistant</h3>
            <p>Smart study companion: summaries, explanations, quizzes and personalized study plans.</p>
          </div>
          <div class="meta-row">
            <div style="font-size:13px; opacity:.95">Last update • persona tuned</div>
            <button class="chat-btn" id="openChatBtn" aria-haspopup="dialog" aria-controls="chatPanel">Chat Now</button>
          </div>
        </div>
      </article>

      <div style="text-align:center; color:var(--muted); font-size:13px; max-width:760px; margin-top:6px;">
        This demo shows one Section card. Click <strong>Chat Now</strong> to open the Study Assistant chat UI (animated).
      </div>
    </main>
  </div>

  <div class="chat-panel" id="chatPanel" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="chat-shell" role="document" aria-label="Study chat">
     <button id="scrollToBottomBtn" class="scroll-to-bottom-btn" title="Scroll to bottom">
  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14m-7-7l7 7 7-7"/></svg>
</button>
      <div class="chat-header">
        <div class="left-controls" aria-hidden="false" style="flex-shrink:0;">
          <button class="back-btn" id="backBtn" title="Back">←</button>
          <button id="convosBtn" class="convos-btn" title="Conversations" aria-haspopup="dialog" aria-expanded="false">
            <span class="lines" aria-hidden="true"><i></i><i></i><i></i></span>
          </button>
        </div>

        <div>
          <div class="persona-name">Study Assistant</div>
          <div class="persona-desc">Focused, concise study help — summaries, quizzes, breakdowns.</div>
        </div>
        <div class="header-spacer"></div>
        <div class="small">Session: <span id="sessionStatus">Local</span></div>
        <button class="kebab-btn" id="chatMenuBtn" title="Menu">⋯</button>
        <div id="chatMenu" class="menu-dropdown" role="menu" aria-hidden="true">
          <button data-cmd="save" title="Download conversation">Download Conversation</button>
          <button data-cmd="report" title="Report an issue">Report</button>
          <button data-cmd="delete" title="Delete all messages">Delete</button>
        </div>
      </div>

      <div id="convoPanel" class="convo-panel" aria-hidden="true">
        <div class="convo-panel-inner" role="navigation" aria-label="Saved conversations">
          <div class="convo-panel-header">
            <button class="convo-close" id="convoCloseBtn" aria-label="Close">×</button>
            <button id="newChatBtn" class="new-chat-btn" title="New chat" aria-label="New chat">
  <svg class="icon" width="18" height="18" viewBox="0 0 24 24" stroke="white" fill="none" aria-hidden="true">
    <path d="M12 5v14M5 12h14" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>
  New Chat
</button>
          </div>
          <div class="convo-chips" id="convoChips" aria-hidden="false"></div>
          <div class="convo-list" id="convoList" role="list"></div>
        </div>
      </div>

      <div id="convoItemMenu" class="convo-item-menu" aria-hidden="true">
        <button id="menuRenameBtn">Rename</button>
        <button id="menuDeleteBtn">Delete</button>
        <button id="menuLockSoonBtn" class="soon">Lock Conversation (soon)</button>
      </div>

      <div id="welcomeBanner" class="welcome-banner" aria-hidden="true">Hi, what would you like to learn today?</div>

      <div class="messages" id="messages" aria-live="polite" aria-atomic="false"></div>

      <div class="composer" role="group" aria-label="Composer">
        <div id="filePreviewContainer" class="file-preview-container" aria-hidden="true"></div>

        <div class="composer-inner">
          <div class="attach-wrap">
            <button id="attachBtn" class="attach-btn" aria-haspopup="true" aria-expanded="false" title="Attach">
              <svg viewBox="0 0 24 24" fill="none" stroke="#0b2633" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M21 15v4a2 2 0 0 1-2 2H7a6 6 0 0 1-6-6V7a2 2 0 0 1 2-2h4"></path>
                <path d="M8 7l8-3 2 3"></path>
              </svg>
            </button>
            <div id="attachPanel" class="attach-panel" aria-hidden="true">
              <button class="attach-option" data-action="camera">Take photo</button>
              <button class="attach-option" data-action="image">Upload image</button>
              <button class="attach-option" data-action="file">Upload file</button>
            </div>
          </div>

          <div class="input-wrap">
              <textarea id="composerInput" class="input-field" placeholder="" aria-label="Message input" autocomplete="off" rows="1"></textarea>
              <div id="rotator" class="rotator" aria-hidden="true">
                  <span class="rotator-text" id="rotatorText"></span>
              </div>
              <button class="send-inside" id="sendInsideBtn" title="Send" aria-label="Send message" type="button">
  <span class="send-icon" aria-hidden="true"></span>
  <span class="stop-icon" aria-hidden="true"></span>
  <span class="sr-only">Send</span>
</button>
          </div>

          <button id="editCancelBtn" class="edit-cancel" title="Cancel edit">Cancel</button>
        </div>
      </div>
    </div>
  </div>

<div class="modal-backdrop" id="confirmModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
    <h3 id="confirmTitle">Delete Conversation</h3>
    <p>You are about to delete the whole conversation. Are you sure?</p>
    <div class="row">
      <button class="btn ghost" data-confirm="no">No</button>
      <button class="btn primary" data-confirm="yes">Yes, delete</button>
    </div>
  </div>
</div>

<div class="modal-backdrop" id="reportModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="reportTitle">
    <h3 id="reportTitle">Report an issue</h3>
    <div id="reportStep1">
      <p>Choose a reason for the report:</p>
      <div class="reason-list" id="reasonList"></div>
      <div class="row">
        <button class="btn ghost" data-report="cancel">Cancel</button>
        <button class="btn primary" data-report="next" disabled>Next</button>
      </div>
    </div>
    <div id="reportStep2" style="display:none;">
      <p>Please provide additional details (optional):</p>
      <textarea class="report-text" id="reportText" placeholder="Please provide details (optional)"></textarea>
      <div class="row">
        <button class="btn ghost" data-report="back">Back</button>
        <button class="btn primary" data-report="send">Send</button>
      </div>
    </div>
  </div>
</div>

<div class="modal-backdrop" id="messageConfirmModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="msgConfirmTitle">
    <h3 id="msgConfirmTitle">Delete Message</h3>
    <p>If you delete this message, all messages after it (user or assistant) will also be removed. Continue?</p>
    <div class="row">
      <button class="btn ghost" data-msg-confirm="no">No</button>
      <button class="btn primary" data-msg-confirm="yes">Yes, delete</button>
    </div>
  </div>
</div>

<div class="modal-backdrop" id="deleteSavedModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="delSavedTitle">
    <h3 id="delSavedTitle">Delete saved conversation</h3>
    <p>Do you really want to delete this saved conversation? This action cannot be undone.</p>
    <div class="row">
      <button class="btn ghost" data-delete="no">No</button>
      <button class="btn primary" data-delete="yes">Yes, delete</button>
    </div>
  </div>
</div>

<div class="modal-backdrop" id="renameModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="renameTitle">
    <h3 id="renameTitle">Rename Conversation</h3>
    <p>Enter a new name for this conversation.</p>
    <input type="text" id="renameInput" class="rename-input" placeholder="New conversation name...">
    <div class="row">
      <button class="btn ghost" data-rename="cancel">Cancel</button>
      <button class="btn primary" data-rename="save" style="background: var(--accent);">Save</button>
    </div>
  </div>
</div>

<div id="imageLightboxRoot" aria-hidden="true"></div>

<div class="toast" id="toast"></div>

<script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js"></script>  
<script src="https://js.puter.com/v2/"></script> <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-firestore.js"></script>  
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
  if (window.pdfjsLib) {
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
  }
  (function(){
 // Firebase Configuration
  var firebaseConfig = {
    apiKey: "AIzaSyCxNO-lAFKB5M6YWvJpzTu30s63J6N7Rek",
    authDomain: "as-space.firebaseapp.com",
    projectId: "as-space",
    storageBucket: "as-space.firebasestorage.app",
    messagingSenderId: "603668140355",
    appId: "1:603668140355:web:df2164f348ba8507b41ff6",
    measurementId: "G-7HJZV2V4ZX"
  };

    // Configure marked.js to use highlight.js for code blocks
marked.setOptions({
  highlight: function(code, lang) {
    const language = hljs.getLanguage(lang) ? lang : 'plaintext';
    return hljs.highlight(code, { language }).value;
  }
});

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
    function toast(msg, duration=1900){
      const t = document.getElementById('toast');
      if(!t) return;
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(()=> t.classList.remove('show'), duration);
    }
    function isRTL(text) {
    const rtlRegex = /[\u0600-\u06FF\u0750-\u077F]/;
    return rtlRegex.test(text);
}
    // helper: try to initialize SVG rect stroke length safely (retries via rAF)
function ensureRectInitialized(rect, cb) {
  let attempts = 0;
  function tryInit() {
    try {
      if (!rect || typeof rect.getTotalLength !== 'function') throw new Error('no-getTotalLength');
      const len = rect.getTotalLength();
      rect._totalLen = len;
      rect.style.strokeDasharray = String(len);
      rect.style.strokeDashoffset = String(len); // hide initially
      rect.style.transition = 'stroke-dashoffset 120ms linear, opacity .6s ease';
      if (typeof cb === 'function') cb(len);
      return;
    } catch (err) {
      attempts++;
      if (attempts < 8) {
        // try next paint frame
        requestAnimationFrame(tryInit);
      } else {
        console.warn('ensureRectInitialized failed after retries', err);
        if (typeof cb === 'function') cb(null);
      }
    }
  }
  tryInit();
}

// helper to set progress (uses stored _totalLen if available)
function setRectProgress(rect, pct) {
  try {
    const len = rect && (rect._totalLen || (typeof rect.getTotalLength === 'function' ? rect.getTotalLength() : null));
    if (!len && len !== 0) return;
    const draw = Math.max(0, Math.round(len * (1 - (Number(pct) || 0) / 100)));
    rect.style.strokeDashoffset = String(draw);
  } catch (e) {
    // ignore
  }
}
    function scheduleDeletionOnServer(url){
  try {
    fetch(url, { method: 'DELETE' })
      .then(r => r.json())
      .then(d => console.log('server deletion ok', d))
      .catch(e => console.error('server deletion failed', e));
  } catch(err){
    console.error('scheduleDeletionOnServer error', err);
  }
}

    // copy helper with fallback (fixes mobile "copy not available")
    async function copyTextToClipboard(text){
      if(!text) return false;
      try{
        if(navigator.clipboard && navigator.clipboard.writeText){
          await navigator.clipboard.writeText(text);
          return true;
        }
      }catch(e){}
      // fallback to textarea + execCommand
      try{
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.setAttribute('readonly','');
        ta.style.position = 'absolute';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        ta.setSelectionRange(0, ta.value.length);
        const ok = document.execCommand('copy');
        ta.remove();
        return !!ok;
      }catch(e){}
      return false;
    }

    window.addEventListener('DOMContentLoaded', () => {
      // set a base history state so the phone back button behaves sensibly on the main card screen
      try { history.replaceState({ui:'root'}, ''); } catch(e){}

      const rotator = document.getElementById('rotator');
      const rotatorText = document.getElementById('rotatorText');
      const openChatBtn = document.getElementById('openChatBtn');
      const chatPanel = document.getElementById('chatPanel');
      const backBtn = document.getElementById('backBtn');
      const messagesEl = document.getElementById('messages');
      const composer = document.getElementById('composerInput');
      const sendInsideBtn = document.getElementById('sendInsideBtn');
      const attachBtn = document.getElementById('attachBtn');
      const attachPanel = document.getElementById('attachPanel');
      const editCancelBtn = document.getElementById('editCancelBtn');
      const chatMenuBtn = document.getElementById('chatMenuBtn');
      const chatMenu = document.getElementById('chatMenu');
      const confirmModal = document.getElementById('confirmModal');
      const reportModal = document.getElementById('reportModal');
      const reasonListEl = document.getElementById('reasonList');
      const reportStep1 = document.getElementById('reportStep1');
      const reportStep2 = document.getElementById('reportStep2');
      const reportText = document.getElementById('reportText');
      const messageConfirmModal = document.getElementById('messageConfirmModal');
      const welcomeBanner = document.getElementById('welcomeBanner');
      const filePreviewContainer = document.getElementById('filePreviewContainer');
      const imageLightboxRoot = document.getElementById('imageLightboxRoot');
      const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');

      // --- START: DYNAMIC THEME LOGIC ---
const themeToggleBtn = document.getElementById('theme-toggle-btn');
const lightThemeUrl = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/stackoverflow-light.min.css';
const darkThemeUrl = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css';

// دالة لتغيير ملف تصميم تلوين الأكواد
function setTheme(theme) {
    let themeLink = document.getElementById('highlight-theme');
    if (theme === 'dark') {
        document.body.classList.add('dark-mode');
        if (themeLink) themeLink.href = darkThemeUrl;
        localStorage.setItem('chat_theme', 'dark');
    } else {
        document.body.classList.remove('dark-mode');
        if (themeLink) themeLink.href = lightThemeUrl;
        localStorage.setItem('chat_theme', 'light');
    }
}

// عند الضغط على زر التبديل
themeToggleBtn.addEventListener('click', () => {
    if (document.body.classList.contains('dark-mode')) {
        setTheme('light');
    } else {
        setTheme('dark');
    }
});

// عند تحميل الصفحة، تحقق من الوضع المحفوظ
const savedTheme = localStorage.getItem('chat_theme');
if (savedTheme) {
    setTheme(savedTheme);
} else {
    setTheme('light'); // الوضع الافتراضي
}
// --- END: DYNAMIC THEME LOGIC ---

  messagesEl.addEventListener('scroll', () => {
    // إذا قام المستخدم بالتمرير للأعلى لمسافة معينة، أظهر الزر
    if (messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight > 200) {
      scrollToBottomBtn.classList.add('visible');
    } else {
      scrollToBottomBtn.classList.remove('visible');
    }
  });

  scrollToBottomBtn.addEventListener('click', () => {
    messagesEl.scrollTo({
      top: messagesEl.scrollHeight,
      behavior: 'smooth'
    });
  });

      // conversation sidebar elements
      const convosBtn = document.getElementById('convosBtn');
      const convoPanel = document.getElementById('convoPanel');
      const convoCloseBtn = document.getElementById('convoCloseBtn');
      const newChatBtn = document.getElementById('newChatBtn');
      const convoChips = document.getElementById('convoChips');
      const convoList = document.getElementById('convoList');
      const deleteSavedModal = document.getElementById('deleteSavedModal');

      // menu (contextual) elements
      const convoItemMenu = document.getElementById('convoItemMenu');
      const menuRenameBtn = document.getElementById('menuRenameBtn');
      const menuDeleteBtn = document.getElementById('menuDeleteBtn');
      const menuLockSoonBtn = document.getElementById('menuLockSoonBtn');

      let convoMenuTargetIndex = null; // which savedConvo index the contextual menu is for
      let pendingMessageDeleteIndex = null;
      let userActionsTimeout = null; // MODIFICATION: Timeout for user actions
      let pendingDeleteId = null;

      // 🟢 conversation id (current)
let currentConversationId = localStorage.getItem('currentConversationId') || null;

function newConversation() {
  try {
    currentConversationId = 'conv_' + (crypto && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2,10));
  } catch (e) {
    currentConversationId = 'conv_' + Math.random().toString(36).slice(2,10);
  }
  localStorage.setItem('currentConversationId', currentConversationId);
  // هنا ممكن تفرغ الرسائل من الواجهة مثلا:
  messagesEl.innerHTML = '';
}

      // file inputs
      const cameraInput = document.createElement('input');
      cameraInput.type = 'file'; cameraInput.accept = 'image/*'; cameraInput.capture = 'environment'; cameraInput.style.display='none';
      const imageInput = document.createElement('input');
      imageInput.type = 'file'; imageInput.accept = 'image/*'; imageInput.style.display='none';
      const fileInput = document.createElement('input');
      fileInput.type = 'file'; fileInput.style.display='none';
      document.body.appendChild(cameraInput);
      document.body.appendChild(imageInput);
      document.body.appendChild(fileInput);

      // allowed types (extensions)
const allowedExt = [
  // صور
  'png','jpg','jpeg','webp','gif','bmp','svg',

  // نصوص وأكواد
  'txt','md','log','json','js','ts','css','html','htm','xml','csv','yml','yaml',

  // مستندات
  'pdf','doc','docx','ppt','pptx','xls','xlsx'
];

// السماح بأي نوع يبدأ بـ image/ + بعض الأنواع الإضافية
const allowedMimePrefixes = ['image/'];

// أنواع إضافية صريحة
const allowedMimesExtra = [
  'application/pdf',
  'text/plain',
  'text/html',
  'application/json',
  'application/javascript',
  'text/css',
  'application/xml',
  'text/csv',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // docx
  'application/msword',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'application/vnd.ms-powerpoint',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation'
];

      // pendingAttachment holds current file preview & upload state
      let pendingAttachment = null;

      // conversation history saved (array of {id, title, messages, createdAt})
      const HISTORY_KEY = 'chat_study_history';
      let savedConvos = [];

      // current session id (used for autosave entry in savedConvos)
      const CURRENT_ID_KEY = 'chat_study_current_id';
      let currentSessionId = null;

      // helpers for history
      function loadHistory(){
        try{
          const raw = localStorage.getItem(HISTORY_KEY);
          savedConvos = raw ? JSON.parse(raw) : [];
        }catch(e){ savedConvos = []; }
      }
      function saveHistory(){
        try{ localStorage.setItem(HISTORY_KEY, JSON.stringify(savedConvos)); }catch(e){}
      }

      function loadCurrentSessionId(){
        try {
          const v = localStorage.getItem(CURRENT_ID_KEY);
          if(v && typeof v === 'string'){ currentSessionId = v; }
          else { currentSessionId = 's-'+Math.random().toString(36).slice(2,9); localStorage.setItem(CURRENT_ID_KEY, currentSessionId); }
        } catch(e) { currentSessionId = 's-'+Math.random().toString(36).slice(2,9); try{ localStorage.setItem(CURRENT_ID_KEY, currentSessionId); }catch(_e){} }
      }

      // persist current messages into savedConvos under currentSessionId (autosave).
      // only create/update if there are messages (do not create empty records).
      function persistCurrentToHistory(){
        try{
          if(!Array.isArray(messages)) return;
          if(messages.length === 0) return; // do not autosave empty convs
          if(!currentSessionId){ loadCurrentSessionId(); }
          const idx = savedConvos.findIndex(c => c.id === currentSessionId);
          const title = generateConversationTitle(messages);
          const conv = { id: currentSessionId, title: title, messages: JSON.parse(JSON.stringify(messages)), createdAt: Date.now() };
          if(idx !== -1){
            savedConvos[idx].title = conv.title;
            savedConvos[idx].messages = conv.messages;
            savedConvos[idx].createdAt = savedConvos[idx].createdAt || conv.createdAt;
          } else {
            // put autosaved current chat at top
            savedConvos.unshift(conv);
          }
          saveHistory();
          try { renderHistoryPanel(); } catch(e){}
        }catch(e){ console.error('persistCurrentToHistory', e); }
      }

      // helpers
      function isAllowedFile(file){
        if(!file) return false;
        const name = (file.name || '').toLowerCase();
        const ext = name.split('.').pop() || '';
        if(allowedExt.includes(ext)) return true;
        const mt = file.type || '';
        for(const p of allowedMimePrefixes) if(mt.startsWith(p)) return true;
        if(allowedMimesExtra.includes(mt)) return true;
        return false;
      }

      function handleFileSelection(files){
  if (!files || files.length === 0) return;
  const f = files[0];
  if (!isAllowedFile(f)) {
    toast('File type not supported');
    return;
  }

  // 🟢 هنا التعديل: الصور فقط (png/jpg/jpeg/gif/webp) تروح لـ showImagePreview
  const imgTypes = ['image/png','image/jpeg','image/jpg','image/gif','image/webp'];
  if (f.type && imgTypes.includes(f.type.toLowerCase())) {
    showImagePreview(f);
  } else {
    showFilePreview(f);
  }
}
      cameraInput.addEventListener('change', (e)=> handleFileSelection(e.target.files));
      imageInput.addEventListener('change', (e)=> handleFileSelection(e.target.files));
      fileInput.addEventListener('change', (e)=> handleFileSelection(e.target.files));
      function openAttach(){ attachPanel.classList.add('open'); attachPanel.setAttribute('aria-hidden','false'); attachBtn.setAttribute('aria-expanded','true'); }
      function closeAttach(){ attachPanel.classList.remove('open'); attachPanel.setAttribute('aria-hidden','true'); attachBtn.setAttribute('aria-expanded','false'); }
      attachBtn.addEventListener('click', (e)=>{ e.stopPropagation(); if(attachPanel.classList.contains('open')) closeAttach(); else { closeMenus(); openAttach(); } });
      attachPanel.querySelectorAll('.attach-option').forEach(opt=>{
        opt.addEventListener('click', (ev)=>{
          const action = opt.dataset.action;
          closeAttach();
          if(action==='camera'){ cameraInput.click(); }
          else if(action==='image'){ imageInput.click(); }
          else if(action==='file'){ fileInput.click(); }
        });
      });

      // clear preview
      function clearPreview(){
        if(!filePreviewContainer) return;
        filePreviewContainer.innerHTML = '';
        filePreviewContainer.setAttribute('aria-hidden','true');
        try{
          if(pendingAttachment){
            if(pendingAttachment._uploadInterval) { clearInterval(pendingAttachment._uploadInterval); pendingAttachment._uploadInterval = null; }
            if(pendingAttachment._timeoutTimer) { clearTimeout(pendingAttachment._timeoutTimer); pendingAttachment._timeoutTimer = null; }
            if(pendingAttachment._objectUrl){ try{ URL.revokeObjectURL(pendingAttachment._objectUrl); }catch(e){} }
          }
        }catch(e){}
        pendingAttachment = null;
        updateSendVisibility();
        updateComposerSpacing();
      }

      // ===== upload simulation (keeps previous behavior) =====
      const UPLOAD_TIMEOUT_MS = 3 * 60 * 1000; // 3 minutes

      
      // === startUploadSimulation (fixed, robust) ===
// Simulated progress for preview ring. This function will:
// - slowly advance a simulated progress up to 98%,
// - stop immediately and call onComplete() if pending._useRealUpload becomes true,
// - clean up intervals and call onComplete when simulation finishes.
function startUploadSimulation(pending, outer, rect, onComplete, onTick) {
  try {
    if (!pending) return;

    // clear any existing interval
    if (pending._uploadInterval) {
      clearInterval(pending._uploadInterval);
      pending._uploadInterval = null;
    }

    // ensure state
    pending.uploadState = pending.uploadState || 'pending';
    pending.progress = pending.progress || 0;

    // prepare SVG stroke if available
    let totalLen = null;
    try {
      if (rect && typeof rect.getTotalLength === 'function') {
        totalLen = rect.getTotalLength();
        rect.style.strokeDasharray = String(totalLen);
        // start _fully_ hidden then draw according to progress
        const startOffset = Math.round(totalLen * (1 - (pending.progress || 0) / 100));
        rect.style.strokeDashoffset = String(startOffset);
        rect.style.transition = 'stroke-dashoffset 120ms linear, opacity .6s ease';
      }
    } catch (e) {
      console.error('startUploadSimulation setup error', e);
    }

    let lastTime = Date.now();

    pending._uploadInterval = setInterval(() => {
      try {
        if (!pending) {
          if (pending && pending._uploadInterval) {
            clearInterval(pending._uploadInterval);
            pending._uploadInterval = null;
          }
          return;
        }

        // if a real upload was triggered, stop simulation and notify
        if (pending._useRealUpload) {
          if (pending._uploadInterval) {
            clearInterval(pending._uploadInterval);
            pending._uploadInterval = null;
          }
          pending.uploadState = pending.uploadState || 'pending';
          if (typeof onComplete === 'function') onComplete();
          return;
        }

        // stop if failed or already complete
        if (pending.uploadState === 'failed' || pending.uploadState === 'complete') {
          if (pending._uploadInterval) {
            clearInterval(pending._uploadInterval);
            pending._uploadInterval = null;
          }
          if (pending.uploadState === 'complete' && typeof onComplete === 'function') onComplete();
          return;
        }

        // gentle random progress increment but leave room for the real upload
        const now = Date.now();
        const dt = Math.max(80, Math.min(1200, now - lastTime));
        lastTime = now;

        const inc = 1 + Math.floor(Math.random() * 4); // small bump
        pending.progress = Math.min(98, (pending.progress || 0) + inc);

        // update ring visually
        if (rect && totalLen) {
          const draw = Math.max(0, Math.round(totalLen * (1 - (pending.progress / 100))));
          rect.style.strokeDashoffset = draw;
        }

        // tick callback (update UI)
        if (typeof onTick === 'function') {
          try { onTick(); } catch(e){}
        }

        // if we reached simulation threshold -> stop and call onComplete
        if ((pending.progress || 0) >= 98) {
          if (pending._uploadInterval) {
            clearInterval(pending._uploadInterval);
            pending._uploadInterval = null;
          }
          // mark ready (not actually uploaded yet)
          pending.uploadState = 'pending';
          if (typeof onComplete === 'function') onComplete();
          return;
        }
      } catch (e) {
        console.error('startUploadSimulation tick error', e);
      }
    }, 120 + Math.round(Math.random() * 180));
  } catch (e) {
    console.error('startUploadSimulation error', e);
  }
}

      // show image preview
function showImagePreview(file){
  try {
    if(!filePreviewContainer) return;
    clearPreview();
    filePreviewContainer.setAttribute('aria-hidden','false');

    const outer = document.createElement('div');
    outer.className = 'thumb-outer';

    const svgNS = 'http://www.w3.org/2000/svg';
    const svgEl = document.createElementNS(svgNS, 'svg');
    svgEl.setAttribute('class', 'thumb-svg');
    svgEl.setAttribute('viewBox', '0 0 100 100');
    svgEl.setAttribute('preserveAspectRatio', 'none');
    svgEl.style.transform = 'rotate(-90deg)';
    svgEl.style.transformOrigin = '50% 50%';

    const rect = document.createElementNS(svgNS, 'rect');
    rect.setAttribute('x', '6'); rect.setAttribute('y', '6');
    rect.setAttribute('width', '88'); rect.setAttribute('height', '88');
    rect.setAttribute('rx', '12'); rect.setAttribute('ry', '12');
    rect.setAttribute('fill', 'none');
    rect.setAttribute('stroke', 'rgba(0,120,255,0.98)');
    rect.setAttribute('stroke-width', '4');
    rect.setAttribute('stroke-linecap', 'round');
    rect.setAttribute('stroke-linejoin', 'round');

    svgEl.appendChild(rect);
    outer.appendChild(svgEl);

    const imgWrap = document.createElement('div');
    imgWrap.className = 'file-thumb-img';
    const imgEl = document.createElement('img');
    imgEl.alt = file.name || 'image';
    imgWrap.appendChild(imgEl);
    outer.appendChild(imgWrap);

    const retry = document.createElement('div');
    retry.className = 'retry-overlay';
    retry.title = 'Retry upload';
    retry.innerHTML = '↻';
    outer.appendChild(retry);

    // زر الإغلاق مخفي حتى ينتهي الرفع (أو يحدث فشل)
    const closeBtn = document.createElement('button');
    closeBtn.className = 'thumb-close';
    closeBtn.title = 'Remove';
    closeBtn.innerText = '×';
    closeBtn.style.display = 'none';
    outer.appendChild(closeBtn);

    filePreviewContainer.appendChild(outer);
    updateComposerSpacing();

    const reader = new FileReader();
    reader.onload = function(ev){
      // show image
      imgEl.src = ev.target.result;

      // prepare pendingAttachment
      pendingAttachment = {
        type: 'image',
        name: file.name,
        size: file.size,
        src: ev.target.result,
        file: file,
        progress: 0,
        uploadState: 'pending',
        sendOnComplete: false,
        _sending: false,
        _outer: outer,
        _rect: rect
      };

      updateSendVisibility();

      // ensure rect length is initialized (safely)
      ensureRectInitialized(rect, (len)=>{
        // rect initialized (or failed). if there's already some progress, reflect it
        try { setRectProgress(rect, pendingAttachment.progress || 0); } catch(e){}
      });

      // start real upload (with progress callback)
      uploadFileToServer(file, (pct, loaded, total) => {
        try {
          pendingAttachment.progress = pct;
          pendingAttachment.uploadState = 'uploading';
          setRectProgress(rect, pct);
          updateSendVisibility();
        } catch(_){}
      }).then(result => {
        // success
        pendingAttachment.uploadState = 'done';
        pendingAttachment.progress = 100;
        pendingAttachment.id = result.id;
        pendingAttachment.url = result.url;
        pendingAttachment.filename = result.filename;
        pendingAttachment.mime_type = result.mime_type;
        pendingAttachment._uploadResult = result;

        // show close button now that file is uploaded
        try { closeBtn.style.display = 'block'; } catch(e){}

        try {
          setRectProgress(rect, 100);
          if (outer) {
            outer.classList.remove('uploading','upload-failed');
            outer.classList.add('upload-complete');
            setTimeout(()=>{ try{ outer.classList.add('clean-ring'); }catch(e){} }, 600);
          }
        } catch(e){}

        toast('Upload complete! Click send to post it.');
        updateSendVisibility();

        // (analysis removed here — analysis will run only after user presses Send)
        
      }).catch(err => {
        console.error('upload failed', err);
        pendingAttachment.uploadState = 'failed';
        pendingAttachment.progress = 0;
        try {
          if (outer) { outer.classList.remove('uploading'); outer.classList.add('upload-failed'); }
          // show close so user can remove failed preview
          closeBtn.style.display = 'block';
        } catch(e){}
        toast('Upload failed, try again.');
        updateSendVisibility();
      });
    };
    reader.readAsDataURL(file);

    // close button: delete remote file (if uploaded) and clear preview
    closeBtn.addEventListener('click', async (ev)=>{
      ev.preventDefault();
      try {
        const remoteId = pendingAttachment && (pendingAttachment.id || (pendingAttachment._uploadResult && pendingAttachment._uploadResult.id));
        if (remoteId) {
          await fetch(API_BASE + '/api/files/' + remoteId, { method: 'DELETE' }).catch(()=>{});
        }
      } catch(e){
        console.warn('delete failed', e);
      }
      try { if (pendingAttachment && pendingAttachment._objectUrl) URL.revokeObjectURL(pendingAttachment._objectUrl); } catch(e){}
      clearPreview();
      pendingAttachment = null;
      updateSendVisibility();
    });

    // retry button
    retry.addEventListener('click', (ev)=>{
      ev.preventDefault();
      if(!pendingAttachment || !pendingAttachment.file) return;
      pendingAttachment.progress = 0;
      pendingAttachment.uploadState = 'pending';
      outer.classList.remove('upload-failed','upload-complete','clean-ring');
      // restart upload
      uploadFileToServer(pendingAttachment.file, (pct)=> {
        try {
          pendingAttachment.progress = pct;
          pendingAttachment.uploadState = 'uploading';
          setRectProgress(rect, pct);
          updateSendVisibility();
        } catch(e){}
      }).then(result => {
        pendingAttachment.uploadState = 'done';
        pendingAttachment.progress = 100;
        pendingAttachment.id = result.id;
        pendingAttachment.url = result.url;
        pendingAttachment.filename = result.filename;
        pendingAttachment.mime_type = result.mime_type;
        pendingAttachment._uploadResult = result;
        try { closeBtn.style.display = 'block'; } catch(e){}
        updateSendVisibility();
        toast('Upload complete! Click send to post it.');
      }).catch(err => {
        console.warn('retry upload failed', err);
        pendingAttachment.uploadState = 'failed';
        updateSendVisibility();
      });
    });

  } catch(e){
    console.error('preview image error', e);
  }
}

      // show generic file preview
function showFilePreview(file){
  try {
    if(!filePreviewContainer) return;
    clearPreview();
    filePreviewContainer.setAttribute('aria-hidden','false');

    const outer = document.createElement('div');
    outer.className = 'thumb-outer';

    const svgNS = 'http://www.w3.org/2000/svg';
    const svgEl = document.createElementNS(svgNS, 'svg');
    svgEl.setAttribute('class', 'thumb-svg');
    svgEl.setAttribute('viewBox', '0 0 100 100');
    svgEl.setAttribute('preserveAspectRatio', 'none');
    svgEl.style.transform = 'rotate(-90deg)';
    svgEl.style.transformOrigin = '50% 50%';

    const rect = document.createElementNS(svgNS, 'rect');
    rect.setAttribute('x', '6'); rect.setAttribute('y', '6');
    rect.setAttribute('width', '88'); rect.setAttribute('height', '88');
    rect.setAttribute('rx', '12'); rect.setAttribute('ry', '12');
    rect.setAttribute('fill', 'none');
    rect.setAttribute('stroke', 'rgba(0,120,255,0.98)');
    rect.setAttribute('stroke-width', '4');
    rect.setAttribute('stroke-linecap', 'round');
    rect.setAttribute('stroke-linejoin', 'round');

    svgEl.appendChild(rect);
    outer.appendChild(svgEl);

    // meta area
    const metaWrap = document.createElement('div');
    metaWrap.className = 'file-thumb-meta';
    const fn = document.createElement('div');
    fn.className = 'fname';
    fn.textContent = file.name.split('.').slice(0,2).join('.');
    metaWrap.appendChild(fn);
    outer.appendChild(metaWrap);

    const retry = document.createElement('div');
    retry.className = 'retry-overlay';
    retry.title = 'Retry upload';
    retry.innerHTML = '↻';
    outer.appendChild(retry);

    const closeBtn = document.createElement('button');
    closeBtn.className = 'thumb-close';
    closeBtn.title = 'Remove';
    closeBtn.innerText = '×';
    closeBtn.style.display = 'none'; // hidden until upload done/failed
    outer.appendChild(closeBtn);

    filePreviewContainer.appendChild(outer);
    updateComposerSpacing();

    const objectUrl = URL.createObjectURL(file);

    pendingAttachment = {
      type: 'file',
      name: file.name,
      size: file.size,
      src: objectUrl,
      file: file,
      _objectUrl: objectUrl,
      progress: 0,
      uploadState: 'pending',
      sendOnComplete: false,
      _sending: false,
      _outer: outer,
      _rect: rect
    };
    updateSendVisibility();

    // ensure rect initialized safely
    ensureRectInitialized(rect, (len) => {
      // reflect any existing progress
      try { setRectProgress(rect, pendingAttachment.progress || 0); } catch(e){}
    });

    // ---- start real upload immediately for files ----
    uploadFileToServer(file, (pct, loaded, total) => {
      try {
        pendingAttachment.progress = pct;
        pendingAttachment.uploadState = 'uploading';
        setRectProgress(rect, pct);
        updateSendVisibility();
      } catch(_){}
    }).then(result => {
      pendingAttachment.uploadState = 'done';
      pendingAttachment.progress = 100;
      pendingAttachment.id = result.id;
      pendingAttachment.url = result.url;
      pendingAttachment.filename = result.filename;
      pendingAttachment.mime_type = result.mime_type;
      pendingAttachment._uploadResult = result;

      try {
        setRectProgress(rect, 100);
        if (outer) {
          outer.classList.remove('uploading','upload-failed');
          outer.classList.add('upload-complete');
          setTimeout(()=>{ try{ outer.classList.add('clean-ring'); }catch(e){} }, 600);
        }
      } catch(e){}

      // show delete X now
      try { closeBtn.style.display = 'block'; } catch(e){}

      toast('Upload complete! Click send to post it.');
      updateSendVisibility();
      
    }).catch(err => {
      console.error('retry upload failed', err);
      pendingAttachment.uploadState = 'failed';
      pendingAttachment.progress = 0;
      try { if (outer) { outer.classList.remove('uploading'); outer.classList.add('upload-failed'); } } catch(e){}
      // show delete so user can remove failed preview
      try { closeBtn.style.display = 'block'; } catch(e){}
      toast('Upload failed, try again.');
      updateSendVisibility();
    });

    // close button: delete remote file + cleanup
closeBtn.addEventListener('click', (ev)=>{
  ev.preventDefault();

  // 🟢 امسح المعاينة مباشرة من الواجهة
  clearPreview();
  pendingAttachment = null;
  updateSendVisibility();

  // 🟡 الحذف من السيرفر يتم في الخلفية
  try {
    const remoteId = pendingAttachment && (pendingAttachment.id || (pendingAttachment._uploadResult && pendingAttachment._uploadResult.id));
    if (remoteId) {
      fetch(API_BASE + '/api/files/' + remoteId, { method: 'DELETE' })
        .catch(()=>{ console.warn('delete request failed'); });
    }
  } catch(e){
    console.warn('delete failed', e);
  }

  try { 
    if (pendingAttachment && pendingAttachment._objectUrl) {
      URL.revokeObjectURL(pendingAttachment._objectUrl);
    }
  } catch(e){}
});

    // retry overlay — re-run the real upload
    retry.addEventListener('click', (ev)=>{
      ev.preventDefault();
      if(!pendingAttachment || !pendingAttachment.file) return;
      pendingAttachment.progress = 0;
      pendingAttachment.uploadState = 'pending';
      outer.classList.remove('upload-failed','upload-complete','clean-ring');
      uploadFileToServer(pendingAttachment.file, (pct)=> {
        try {
          pendingAttachment.progress = pct;
          pendingAttachment.uploadState = 'uploading';
          setRectProgress(rect, pct);
          updateSendVisibility();
        } catch(e){}
      }).then(result => {
        pendingAttachment.uploadState = 'done';
        pendingAttachment.progress = 100;
        pendingAttachment.id = result.id;
        pendingAttachment.url = result.url;
        pendingAttachment.filename = result.filename;
        pendingAttachment.mime_type = result.mime_type;
        pendingAttachment._uploadResult = result;
        try { closeBtn.style.display = 'block'; } catch(e){}
        updateSendVisibility();
        toast('Upload complete! Click send to post it.');
      }).catch(err => {
        console.warn('retry upload failed', err);
        pendingAttachment.uploadState = 'failed';
        updateSendVisibility();
      });
    });

  } catch(e){
    console.error('preview file error', e);
  }
}
      // ===== helper: extract readable text from Puter response (robust) =====
function parsePuterResult(res) {
  try {
    if (!res) return null;
    if (typeof res === 'string') return res.trim();

    const getString = v => (typeof v === 'string' && v.trim()) ? v.trim() : null;

    // common top-level fields
    for (const k of ['text','description','summary','output','data']) {
      if (getString(res[k])) return res[k];
    }

    function decodeFilename(name) {
  try {
    // يحاول تحويل الاسم من Latin-1/URL-encoded إلى UTF-8
    return decodeURIComponent(escape(name));
  } catch(e) {
    return name; // fallback لو فشل
  }
}

    // shape: { message: { content: ... } }
    if (res.message) {
      const c = res.message.content || res.message.text || res.message;
      if (getString(c)) return c;
      if (typeof c === 'object') {
        if (Array.isArray(c.parts)) {
          for (const p of c.parts) {
            const s = getString(p) || getString(p.text) || getString(p.content);
            if (s) return s;
          }
        }
        for (const kk of ['text','content','description','summary']) {
          if (getString(c[kk])) return c[kk];
        }
      }
    }

    // choices array
    if (Array.isArray(res.choices) && res.choices.length) {
      const c = res.choices[0];
      if (getString(c.text)) return c.text;
      if (c.message) {
        const s = parsePuterResult(c.message);
        if (s) return s;
      }
    }

    // fallback: first string leaf
    const findStringLeaf = (obj, depth = 0) => {
      if (!obj || depth > 6) return null;
      if (typeof obj === 'string') return obj.trim();
      if (Array.isArray(obj)) {
        for (const it of obj) {
          const s = findStringLeaf(it, depth + 1);
          if (s) return s;
        }
      } else if (typeof obj === 'object') {
        for (const key of Object.keys(obj)) {
          const s = findStringLeaf(obj[key], depth + 1);
          if (s) return s;
        }
      }
      return null;
    };
    return findStringLeaf(res, 0);
  } catch (e) {
    return null;
  }
}
      
      // === sendAttachmentNow (FINAL VERSION WITH NEW ANIMATIONS) ===
async function sendAttachmentNow() {
  try {
    if (!pendingAttachment) return;
    if (pendingAttachment._sending) return;

    const text = (composer.value || '').trim();
    const userMessage = {
      id: genId(),
      role: 'user',
      content: text || '',
     attachment: {
  id: pendingAttachment.id,
  url: pendingAttachment.url || pendingAttachment.src,
  filename: decodeFilename(pendingAttachment.filename || pendingAttachment.name),
  mime_type: pendingAttachment.mime_type || pendingAttachment.type || ''
},
      conversation_id: currentConversationId || null,
      meta: {}
    };
    // helper: returns 'image' | 'file' | 'default'
function getAttachmentType(att) {
  if (!att) return 'default';
  const mime = (att.mime_type || att.type || '').toLowerCase();
  if (mime.startsWith('image/')) return 'image';
  return 'file';
}

    // 1. عرض رسالة المستخدم ومسح حقل الكتابة
    messages.push(userMessage);
    appendMessage(userMessage, messages.length - 1);
    // show typing/analyzing indicator immediately for the attachment
clearIndicator();
const attType = getAttachmentType(pendingAttachment || userMessage.attachment);
const attachmentIndicator = showTyping(attType); // سيعطي العنصر المرجعي
    saveSession();
    updateWelcomeVisibility();
    composer.value = '';
    updateSendVisibility();
    autoGrowTextarea();
    
    // تم حذف منطق الأنيميشن من هنا لأنه نُقل إلى الدوال الأخرى

    // 2. انتظار اكتمال الرفع إذا لم يكن قد اكتمل بعد
    if (pendingAttachment.uploadState !== 'done') {
        await uploadFileToServer(pendingAttachment.file, (pct) => {});
    }
    
    postMessageToServer(userMessage).catch(err => {
        console.warn('postMessageToServer failed for attachment message', err);
        scheduleSync();
    });
    
    clearPreview();
    pendingAttachment = null;

    // 3. تحليل المرفق (الدوال ستقوم بإظهار الأنيميشن بنفسها)
    const attached = userMessage.attachment || null;
    let analysisText = null;
    
    if (attached && attached.mime_type && attached.mime_type.startsWith('image/')) {
    analysisText = await analyzeImageWithPuter(attached.url, userMessage.content, attachmentIndicator);
} else if (attached) {
    analysisText = await analyzeFileWithPuter(attached.url, userMessage.content, attachmentIndicator);
}

   // 4. عرض الرد النهائي
// 🟢 لا نضيف رسالة جديدة هنا، لأن analyzeImageWithPuter / analyzeFileWithPuter 
// هما اللي يتكفلوا بإضافة الرسالة عبر stream.
// إذا ما طلع أي رد → fallback
if (!analysisText) {
    regenerateAssistantForParent(messages.length - 1);
}

  } catch (e) {
    console.error('sendAttachmentNow error', e);
    toast('Send failed');
    clearIndicator(); // كإجراء احترازي: قم بإزالة المؤشر عند حدوث خطأ عام
  } finally {
    try { if (pendingAttachment) pendingAttachment._sending = false; } catch (e) {}
  }
}
      document.addEventListener('click', (e)=>{ if(attachPanel.classList.contains('open') && !attachPanel.contains(e.target) && !attachBtn.contains(e.target)) closeAttach(); }, true);

      const STORAGE_KEY = 'chat_study';
      const DRAFT_KEY = 'chat_study_draft';
      const REPORTS_KEY = 'chat_study_reports';
      const API_BASE = "https://backend-as-space-1.onrender.com";
      let messages = [];
      let editIndex = null;
      function genId(){ return 'm-'+Math.random().toString(36).slice(2,9); }
      function escapeHtml(str){ return String(str).replace(/[&<>"]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s])); }

      // === Helpers for deletions ===

      // 🟢 Helper: لفك تشفير أسماء الملفات (خصوصاً العربية)
function decodeFilename(name) {
  try {
    return decodeURIComponent(escape(name));
  } catch (e) {
    return name;
  }
}
function scheduleDeletionOnServer(url, opts = {}) {
  if (!url) return;
  fetch(url, Object.assign({ method: 'DELETE' }, opts)).then(resp=>{
    if (!resp.ok) throw new Error('delete failed: ' + resp.status);
  }).catch(err=>{
    try {
      const key = 'pendingDeletions';
      const arr = JSON.parse(localStorage.getItem(key) || '[]');
      arr.push({ url, opts, ts: Date.now() });
      localStorage.setItem(key, JSON.stringify(arr));
      console.warn('Deletion queued (will retry later)', url);
    } catch(e){ console.warn('queue deletion failed', e); }
  });
}

async function flushPendingDeletions() {
  try {
    const key = 'pendingDeletions';
    const arr = JSON.parse(localStorage.getItem(key) || '[]');
    if (!Array.isArray(arr) || arr.length === 0) return;
    const remaining = [];
    for (const item of arr) {
      try {
        const resp = await fetch(item.url, Object.assign({ method: 'DELETE' }, item.opts || {}));
        if (!resp.ok) {
          remaining.push(item);
        } else {
          console.info('Pending deletion succeeded:', item.url);
        }
      } catch (e) {
        remaining.push(item);
      }
    }
    localStorage.setItem(key, JSON.stringify(remaining));
  } catch(e){ console.warn('flushPendingDeletions error', e); }
}

window.addEventListener('online', flushPendingDeletions);
setTimeout(flushPendingDeletions, 1500);

      // build a plain-text prompt from last N messages (for context)
      function buildChatPrompt(msgs, upToIndex = null, windowSize = 15){
        try{
          const arr = Array.isArray(msgs) ? msgs : (typeof messages !== 'undefined' ? messages : []);
          if(!arr || arr.length === 0) return '';
          // determine slice end
          let end = (typeof upToIndex === 'number' && upToIndex >= 0) ? Math.min(upToIndex, arr.length - 1) : (arr.length - 1);
          let start = Math.max(0, end - windowSize + 1);
          const parts = [];
          for(let i = start; i <= end; i++){
            const m = arr[i];
            if(!m || !m.role) continue;
            const role = (m.role === 'assistant') ? 'Assistant' : ((m.role === 'user') ? 'User' : m.role);
            const text = (m.content || '').trim();
            if(text) parts.push(role + ': ' + text);
            // include attachment reference as short note
            if(m.attachment){
              const a = m.attachment;
              const aname = a.filename || a.name || a.attachment_name || a.attachmentName || '';
              const atype = a.mime_type || a.attachment_type || a.type || '';
              parts.push(role + ' attachment: ' + (aname || atype || (a.url ? 'file' : 'attachment')));
            }
          }
          return parts.join('\n');
        }catch(e){ console.error('buildChatPrompt error', e); return ''; }
      }


      // Load session (new: try server by conversation_id, fallback to localStorage)
async function loadSession(){
  try {
    // ensure currentConversationId is set (read from localStorage if exists)
    try {
      currentConversationId = localStorage.getItem('currentConversationId') || currentConversationId || null;
    } catch(e){ currentConversationId = currentConversationId || null; }

    // if we have a conversation id and API_BASE -> try fetch from server
    if (currentConversationId && typeof API_BASE !== 'undefined' && API_BASE) {
      try {
        const limit = 500;
        const resp = await fetch(API_BASE + '/api/messages?conversation_id=' + encodeURIComponent(currentConversationId) + '&limit=' + limit);
        if (resp.ok) {
          const rows = await resp.json();
          if (Array.isArray(rows)) {
            messages = rows.map(r => {
              return {
                id: 'srv-' + (r.id || Math.random().toString(36).slice(2,9)),
                role: r.role,
                content: r.content || '',
                attachment: (r.attachment_id || r.attachment_url) ? {
                  id: r.attachment_id || null,
                  url: r.attachment_url || null,
                  filename: r.attachment_name || null,
                  mime_type: r.attachment_type || null
                } : null,
                meta: { remoteId: r.id, created_at: r.created_at, conversation_id: r.conversation_id || null }
              };
            });
          }
        }
      } catch (e) {
        console.warn('server fetch failed, fallback to local', e);
      }
    }

    // fallback: load from localStorage إذا ما فيه رسائل من السيرفر
    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        messages = raw ? JSON.parse(raw) : [];
      }catch(e){ messages = []; }
    }

    // ✅ render fallback
    if (typeof renderMessages === 'function') {
      renderMessages();
    } else {
      try { messagesEl.innerHTML = ''; } catch(e){}
      messages.forEach((m, idx) => appendMessage(m, idx));
    }

  } catch (e) {
    console.error('loadSession error', e);
    messages = [];
  }
}
      // saveSession now also triggers autosave into savedConvos
      function saveSession(){ 
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));
          // persist into savedConvos (autosave)
          persistCurrentToHistory();
        } catch(e) { console.error('saveSession error', e); }
      }

      // ----------------------
      // Background sync + file upload helpers
      // ----------------------
      const SYNC_DEBOUNCE = 800; // ms
      let _syncTimer = null;
      let _syncRunning = false;

      function scheduleSync(delay = SYNC_DEBOUNCE){
        if(_syncTimer) clearTimeout(_syncTimer);
        _syncTimer = setTimeout(()=> { syncMessagesToServer(); }, delay);
      }

      async function syncMessagesToServer(){
        if(_syncRunning) return;
        _syncRunning = true;
        try {
          for (let i = 0; i < messages.length; i++){
            const m = messages[i];
            // already persisted remotely?
            if (m.meta && m.meta.remoteId) continue;

            try {
              await postMessageToServer(m, i);
              // small throttle so we don't hammer the API
              await new Promise(r => setTimeout(r, 120));
            } catch (err) {
              console.warn('syncMessagesToServer: stop on error, will retry later', err);
              break; // stop and retry later
            }
          }
        } finally {
          _syncRunning = false;
        }
      }

      // Persist a single message to backend /api/messages
      async function postMessageToServer(msg, index){
        if (!msg || !API_BASE) throw new Error('postMessageToServer: missing message or API_BASE');

        const payload = {
  role: msg.role || 'user',
  content: msg.content || '',
  parent_id: null,
  attachmentId: (msg.attachment && msg.attachment.id) ? msg.attachment.id : null,
  attachmentUrl: (msg.attachment && (msg.attachment.url || msg.attachment.src)) ? (msg.attachment.url || msg.attachment.src) : null,
  attachmentName: (msg.attachment && (msg.attachment.name || msg.attachment.filename)) ? (msg.attachment.name || msg.attachment.filename) : null,
  attachmentType: (msg.attachment && (msg.attachment.type || msg.attachment.mime_type)) ? (msg.attachment.type || msg.attachment.mime_type) : null,
  conversation_id: currentConversationId || null
};

        try {
          const resp = await fetch(API_BASE + '/api/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!resp.ok) throw new Error('post message failed: ' + resp.status);
          const data = await resp.json();
          // mark message as synced
          msg.meta = msg.meta || {};
          msg.meta.remoteId = data.id;
          msg.meta.synced = true;
          saveSession(); // persist meta locally
          return data;
        } catch (err) {
          throw err;
        }
      }

      // Upload a file to /api/files (returns { id, url, filename, mime_type } expected from backend)
      
  // === (NEW) uploadFileToServer ===
// returns Promise resolving to parsed JSON { id, url, filename, mime_type } from backend
function uploadFileToServer(file, onProgress){
  if (!file) return Promise.reject(new Error('uploadFileToServer: missing file'));
  return new Promise((resolve, reject) => {
    try {
      const xhr = new XMLHttpRequest();
      xhr.open('POST', API_BASE + '/api/files', true);
      // use text so we parse robustly (some environments return text)
      xhr.responseType = 'text';

      // track total size if available
      xhr.upload.onprogress = function(e){
        try {
          if (e.lengthComputable) {
            xhr._totalSize = e.total;
            const pct = Math.round((e.loaded / e.total) * 100);
            if (typeof onProgress === 'function') onProgress(pct, e.loaded, e.total);
         } else {
  // lengthComputable = false -> treat as unknown; start from 0 and let the UI show indeterminate/small animation if desired
  if (typeof onProgress === 'function') onProgress(0, 0, 0);
}
        } catch(e){}
      };

      xhr.onload = function(){
        try {
          // ensure final progress callback
          try {
            const total = xhr._totalSize || file.size || 0;
            if (typeof onProgress === 'function') onProgress(100, total, total);
          } catch(e){}

          if (xhr.status >= 200 && xhr.status < 300) {
            const txt = xhr.responseText || xhr.response || '';
            try {
              const json = txt && typeof txt === 'string' ? JSON.parse(txt) : (typeof txt === 'object' ? txt : {});
              resolve(json);
            } catch(e) {
              // parse failure -> still resolve with empty object
              resolve({});
            }
          } else {
            const txt = xhr.responseText || '';
            reject(new Error('file upload failed: ' + xhr.status + ' ' + txt));
          }
        } catch(e){
          reject(e);
        }
      };

      xhr.onerror = function(){ reject(new Error('file upload error')); };
      xhr.onabort = function(){ reject(new Error('file upload aborted')); };
      xhr.ontimeout = function(){ reject(new Error('file upload timeout')); };

      const fd = new FormData();
fd.append('file', file, file.name);

// أضف conversation_id (إن متاح) حتى يخزن السيرفر الرسالة مربوطة بالمحادثة
try {
  if (typeof currentConversationId !== 'undefined' && currentConversationId) {
    fd.append('conversation_id', String(currentConversationId));
  }
} catch(e) { /* ignore if not available */ }

xhr.send(fd);
    } catch (err) {
      reject(err);
    }
  });
}

// 🟢 تحليل الصور
async function analyzeImageWithPuter(imageUrl, userPrompt = null, indicator = null) {
  if (!imageUrl) return null;

  if (!indicator) {
    clearIndicator();
    indicator = showTyping('image');
  }

  const delay = Math.floor(Math.random() * (5000 - 3000 + 1)) + 3000;
  const toAnalyzingTimer = setTimeout(() => {
    try { setToAnalyzing(indicator); } catch(e) {}
  }, delay);

  try {
    if (typeof puter !== 'undefined' && puter.ai && typeof puter.ai.chat === 'function') {
      const basePrompt = (userPrompt && String(userPrompt).trim())
        ? `${String(userPrompt).trim()}\n\nالآن قم بتحليل الصورة التالية:`
        : `صف محتوى هذه الصورة باختصار.`;

      const response = await puter.ai.chat(basePrompt, imageUrl, { model: 'gpt-5-nano', stream: true });

      let botMsg = null;
      let botEl = null;
      let isFirstChunk = true;

      clearTimeout(toAnalyzingTimer);

      for await (const part of response) {
        const piece = part.text || (part.message && part.message.content) || '';
        if (!piece) continue;

        if (isFirstChunk) {
          clearIndicator(); // 🟢 إزالة المؤشر
          botMsg = { id: genId(), role: 'assistant', content: '', meta: {} };
          messages.push(botMsg);
          appendMessage(botMsg, messages.length - 1);
          const botIndex = messages.length - 1;
          botEl = messagesEl.querySelector(`.msg[data-index="${botIndex}"] .bubble`);
          isFirstChunk = false;
        }

        botMsg.content += piece;
        if (botEl) {
          botEl.innerHTML = marked.parse(botMsg.content);
          enhanceCodeBlocks(botEl);
        }
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }
            // --- تنظيف حالة الزر بعد انتهاء stream الصورة ---
      try {
        const btn = document.getElementById('sendInsideBtn');
        if (btn) {
          btn.classList.remove('is-generating', 'is-pending');
          btn.disabled = false;
          if (btn._stopHandler) {
            btn.removeEventListener('click', btn._stopHandler);
            btn._stopHandler = null;
          }
          btn._abortCurrentResponse = null;
        }
      } catch(e){}

      saveSession();
      return botMsg ? botMsg.content : null;
    }
  } catch (err) {
    console.warn('analyzeImageWithPuter failed', err);
  }

  clearTimeout(toAnalyzingTimer);
  clearIndicator();
  return null;
}

      // === Extract text from PDF (supports File or URL) ===
async function extractPdfText(input) {
  // input: File object OR URL string
  try {
    let arrayBuffer;
    if (typeof input === 'string') {
      // fetch URL -> arrayBuffer
      const resp = await fetch(input);
      if (!resp.ok) throw new Error('fetch failed: ' + resp.status);
      arrayBuffer = await resp.arrayBuffer();
    } else if (input instanceof File || input instanceof Blob) {
      // read File/Blob
      arrayBuffer = await new Promise((res, rej) => {
        const fr = new FileReader();
        fr.onload = () => res(fr.result);
        fr.onerror = (e) => rej(e);
        fr.readAsArrayBuffer(input);
      });
    } else {
      throw new Error('unsupported pdf input');
    }

    const typed = new Uint8Array(arrayBuffer);
    const pdf = await pdfjsLib.getDocument({ data: typed }).promise;
    let text = '';

    // محدد لعدم تحميل كل الملف لو كبير — نقرأ أول N صفحات (تقدر تغير)
    const MAX_PAGES = Math.min(pdf.numPages || 0, 20); // نسمح لـ 20 صفحة كحد أعلى
    for (let i = 1; i <= MAX_PAGES; i++) {
      const page = await pdf.getPage(i);
      const content = await page.getTextContent();
      const pageText = content.items.map(it => it.str).join(' ');
      text += '\n' + pageText;
    }

    return text.trim();
  } catch (err) {
    console.warn('extractPdfText failed', err);
    return '';
  }
}
      
// 🟢 تحليل الملفات (النسخة النهائية والمحسّنة)
async function analyzeFileWithPuter(fileOrUrl, userPrompt = null) {
  try {
    if (!fileOrUrl) return null;

   clearIndicator();
const indicator = showTyping("file");

// 🟢 نفس منطق الصور: بعد ثواني يتحول لـ Analyzing file
const delay = Math.floor(Math.random() * (5000 - 3000 + 1)) + 3000;
const toAnalyzingTimer = setTimeout(() => {
  try { setToAnalyzing(indicator); } catch(e) {}
}, delay);

    let textContent = '';
    let fileType = 'file';

    // -- استخراج النص من المصادر المختلفة --
    if (typeof fileOrUrl === 'string') { // حالة الرابط
      const lower = fileOrUrl.toLowerCase();
      if (lower.match(/\.(png|jpe?g|webp|gif|bmp)(?:[?#].*)?$/)) {
        return await analyzeImageWithPuter(fileOrUrl, userPrompt);
      }
      const resp = await fetch(fileOrUrl);
      if (resp.ok) {
        const mime = resp.headers.get("content-type") || "";
        if (mime.includes('pdf')) {
          fileType = 'PDF';
          const arrayBuffer = await resp.arrayBuffer();
          textContent = await extractPdfText(new Blob([arrayBuffer]));
        } else if (mime.startsWith('text/')) {
          fileType = 'text file';
          textContent = await resp.text();
        }
      }
    } else if (fileOrUrl instanceof File) { // حالة الملف المحلي
      const ext = (fileOrUrl.name || '').split('.').pop().toLowerCase();
      if (fileOrUrl.type && fileOrUrl.type.startsWith('image/')) {
        return await analyzeImageWithPuter(fileOrUrl, userPrompt);
      }
      if (ext === 'pdf') {
        fileType = 'PDF';
        textContent = await extractPdfText(fileOrUrl);
      } else {
        fileType = `${ext} file`;
        textContent = await fileOrUrl.text();
      }
    }

    if (!textContent) {
      clearIndicator();
      toast('Could not read the file content.');
      return null;
    }

    // -- الآن، بعد الحصول على النص، نبدأ عملية الرد --
    const basePrompt = (userPrompt && String(userPrompt).trim())
      ? `${String(userPrompt).trim()}\n\nThis is the content of a ${fileType}:\n\n${textContent.slice(0, 8000)}`
      : `Analyze this ${fileType} and provide a summary:\n\n${textContent.slice(0, 8000)}`;

    // نفس منطق الرد التدريجي المستخدم في sendMessage
    let assistantEl = null;
    let bubbleEl = null;
    let assistantMessage = null;
    let isFirstChunk = true;

    const response = await puter.ai.chat(basePrompt, null, { model: 'gpt-5-nano', stream: true });

  
    clearTimeout(toAnalyzingTimer);
    for await (const part of response) {
      const piece = part.text || (part.message && part.message.content) || '';
      if (!piece) continue;

      if (isFirstChunk) {
        clearIndicator(); // إزالة مؤشر "Analyzing"
        assistantMessage = { id: genId(), role: 'assistant', content: '', meta: {} };
        messages.push(assistantMessage);
        assistantEl = createMessageElement(assistantMessage, messages.length - 1);
        messagesEl.appendChild(assistantEl);
        requestAnimationFrame(() => setTimeout(() => assistantEl.classList.add('show'), 20));
        bubbleEl = assistantEl.querySelector('.bubble');
        isFirstChunk = false;
      }

      assistantMessage.content += piece;
if (bubbleEl) {
  bubbleEl.innerHTML = DOMPurify.sanitize(marked.parse(assistantMessage.content));
  enhanceCodeBlocks(bubbleEl);
}
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    if (assistantEl) {
        const codeBlocksToHighlight = assistantEl.querySelectorAll('pre code');
        codeBlocksToHighlight.forEach(block => { hljs.highlightElement(block); });
    }

        // --- تنظيف حالة الزر بعد انتهاء stream الملف ---
    try {
      const btn = document.getElementById('sendInsideBtn');
      if (btn) {
        btn.classList.remove('is-generating', 'is-pending');
        btn.disabled = false;
        if (btn._stopHandler) {
          btn.removeEventListener('click', btn._stopHandler);
          btn._stopHandler = null;
        }
        btn._abortCurrentResponse = null;
      }
    } catch(e){}
    saveSession();
    return assistantMessage.content;

  } catch (e) {
    console.error('analyzeFileWithPuter error', e);
    clearIndicator();
    return null;
  }
}

      async function genericFileAnalysis(file, userPrompt, fileType = "file") {
  try {
    const basePrompt = (userPrompt && String(userPrompt).trim())
      ? `${String(userPrompt).trim()}\n\nهذا ملف من نوع ${fileType}. حاول تلخيص أو وصف محتواه بناءً على النوع.`
      : `حلل هذا ${fileType} وقدم ملخصاً أو استنتاجات عامة.`;

    const botMsg = { id: genId(), role: 'assistant', content: '', meta: {} };
    messages.push(botMsg);
    appendMessage(botMsg, messages.length - 1);
    const botIndex = messages.length - 1;
    const botEl = messagesEl.querySelector(`.msg[data-index="${botIndex}"] .bubble`);

    const response = await puter.ai.chat(basePrompt, null, { model: 'gpt-5-nano', stream: true });

    for await (const part of response) {
      const piece = part.text || (part.message && part.message.content) || '';
      if (piece) {
        botMsg.content += piece;
        if (botEl) {
          botEl.innerHTML = marked.parse(botMsg.content);
          enhanceCodeBlocks(botEl);
        }
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }
    }

    clearIndicator();
    return botMsg.content;
  } catch (e) {
    console.warn("genericFileAnalysis failed", e);
    clearIndicator();
    return null;
  }
}
      function appendAssistantText(text) {
  if (!text) return;
  const botMsg = {
    id: genId(),
    role: "assistant",
    content: String(text).slice(0, 15000),
    meta: {}
  };
  messages.push(botMsg);
  appendMessage(botMsg, messages.length - 1);
  try { saveSession(); } catch(_) {}
}

      function enhanceCodeBlocks(messageElement) {
    if (!messageElement) return;

    const codeBlocks = messageElement.querySelectorAll('pre > code:not(.hljs-enhanced)');
    codeBlocks.forEach(codeBlock => {
        const preElement = codeBlock.parentElement;
        if (preElement.parentElement.classList.contains('code-block-container')) return;

        const language = [...codeBlock.classList].find(cls => cls.startsWith('language-'))?.replace('language-', '') || 'code';

        const container = document.createElement('div');
        container.className = 'code-block-container';

        const header = document.createElement('div');
        header.className = 'code-block-header';

        const langName = document.createElement('span');
        langName.textContent = language;

        const actions = document.createElement('div');
        actions.className = 'code-block-actions';
        
        const copyBtn = document.createElement('button');
        copyBtn.title = 'Copy code';
        copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
        copyBtn.onclick = () => {
            copyTextToClipboard(codeBlock.textContent);
            toast('Code copied!');
        };
        
        const shareBtn = document.createElement('button');
        shareBtn.title = 'Share code';
        shareBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg>`;
        shareBtn.onclick = async () => {
            const codeText = codeBlock.textContent;
            if (navigator.share) {
                try {
                    await navigator.share({ text: codeText });
                } catch (err) {
                    console.warn('Share failed:', err);
                }
            } else {
                copyTextToClipboard(codeText);
                toast('Code copied for sharing!');
            }
        };

        const collapseBtn = document.createElement('button');
        collapseBtn.title = 'Toggle code block';
        collapseBtn.className = 'collapse-btn';
        collapseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`;
        collapseBtn.onclick = () => {
            container.classList.toggle('collapsed');
            collapseBtn.classList.toggle('is-open');
        };

        actions.appendChild(copyBtn);
        actions.appendChild(shareBtn);
        
        const leftSideHeader = document.createElement('div');
        leftSideHeader.style.display = 'flex';
        leftSideHeader.style.alignItems = 'center';
        leftSideHeader.style.gap = '10px';
        leftSideHeader.appendChild(collapseBtn);
        leftSideHeader.appendChild(langName);

        header.appendChild(leftSideHeader);
        header.appendChild(actions);

        preElement.parentNode.insertBefore(container, preElement);
        container.appendChild(header);
        container.appendChild(preElement);

        codeBlock.classList.add('hljs-enhanced'); 
    });
}

      function saveDraft(){ localStorage.setItem(DRAFT_KEY, composer.value || ''); }
      function loadDraft(){
        const d = localStorage.getItem(DRAFT_KEY);
        if(d){ composer.value = d; updateSendVisibility(); autoGrowTextarea(); }
      }

      function createMessageElement(m, idx) {
        const div = document.createElement('div');
        div.className = 'msg ' + (m.role==='user' ? 'user' : 'assistant');
        div.dataset.index = idx;

       const bubble = document.createElement('div');
bubble.className = 'bubble';
bubble.setAttribute('dir', 'auto'); // <-- هذا هو السطر الجديد والمهم

        if (m.content && typeof m.content === 'string' && String(m.content||'').trim()) {
  const txt = document.createElement('div');
 txt.innerHTML = DOMPurify.sanitize(marked.parse(m.content || ''));
  bubble.appendChild(txt);
  enhanceCodeBlocks(bubble);
}

        
         if (m.attachment) {
  const att = m.attachment;
  const mime = att.mime_type || att.attachment_type || att.type || '';
  const name = decodeFilename(att.filename || att.name || 'file');
  let url = att.url || att.src || null;

  const isImage = mime && mime.startsWith('image/');

  if (isImage && url) {
    // 🟢 للصور: اعرضها مباشرة بشكل أوضح
    const img = document.createElement('img');
    img.className = 'att-image';
    img.alt = name;
    img.src = url;
    bubble.appendChild(img);
  } else {
    // 🟢 للملفات الأخرى: عرض البطاقة مع الأيقونة + الاسم + النوع
    const elWrap = document.createElement('div');
    elWrap.className = 'file-card';

    const icon = document.createElement('div');
    icon.className = 'file-icon';
    // ضع نوع الملف داخل الأيقونة (مثلاً PDF أو HTML)
    icon.textContent = (mime.split('/')[1] || mime || 'FILE').toUpperCase();
    elWrap.appendChild(icon);


    const info = document.createElement('div');
    info.className = 'file-info';
    const title = document.createElement('div');
    title.className = 'file-name';
    title.textContent = name;
    info.appendChild(title);
    elWrap.appendChild(info);

    if (url) {
  // instead of textual "Open" link, show download by clicking the whole card (keeps layout)
  elWrap.addEventListener('click', (ev) => {
    // open in new tab
    try { window.open(url, '_blank', 'noopener'); } catch(e){}
  });

  // ensure cursor pointer
  elWrap.style.cursor = 'pointer';
}

    bubble.appendChild(elWrap);
  }
}


        if(!m.attachment && m.content){
          // already added above
        }

        div.appendChild(bubble);

        if(m.role === 'user'){
            const uacts = document.createElement('div');
            uacts.className = 'user-actions';
            uacts.innerHTML = `
              <button class="act-btn" data-act="user-edit" data-tip="Edit"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#0b2633" stroke-width="2"><path d="M3 21v-3.6l11.1-11.1 3.6 3.6L6.6 21H3z"/><path d="M14.1 6.9l3 3"/></svg></button>
              <button class="act-btn" data-act="user-delete" data-tip="Delete"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#0b2633" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg></button>
            `;
            div.appendChild(uacts);
        }
        if(m.role === 'assistant'){
            const actions = document.createElement('div');
            actions.className = 'msg-actions';
            actions.dataset.index = idx;
            const meta = m.meta || {};
            const locked = !!meta.locked;
            const hideReactionButtons = !!meta.hideReactionButtons;
            const liked = !!meta.liked;
            const disliked = !!meta.disliked;
            const tempDisliked = !!meta.tempDisliked;
            const hideDislike = !!meta.hideDislike;
            let html = `<button class="act-btn" data-act="regen" data-tip="Regenerate" title="Regenerate"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#0b2633" stroke-width="2"><path d="M21 12a9 9 0 1 1-3-6.7"/><polyline points="21 3 21 9 15 9"/></svg></button><span class="divider"></span>`;

            if(!hideReactionButtons){
              if(!locked || liked){
                const likeActive = liked ? 'data-active="true"' : '';
                const likeLockedAttr = locked ? 'data-locked="true"' : '';
                 // MODIFICATION: Added stroke-width="2"
                html += `<button class="act-btn" data-act="like" data-tip="Like" title="Like" ${likeActive} ${likeLockedAttr}>
                    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" stroke="${liked ? '#0b80ff' : '#0b2633'}" stroke-linecap="round" stroke-linejoin="round" fill="${liked ? '#0b80ff' : 'none'}">
                    <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>
                    </svg>
                </button>`;
              }
              if(!hideDislike && (!locked || tempDisliked || disliked)){
                const discActive = (tempDisliked || disliked) ? 'data-active="true"' : '';
                // MODIFICATION: Added stroke-width="2"
                html += `<button class="act-btn" data-act="dislike" data-tip="Dislike" title="Dislike" ${discActive}>
                    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" stroke="${disliked ? '#ff4d4f' : '#0b2633'}" stroke-linecap="round" stroke-linejoin="round" fill="${disliked ? '#ff4d4f' : 'none'}">
                    <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zM17 2h3a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2h-3"></path>
                    </svg>
                </button>`;
              }
            }
            // MODIFICATION: Changed share icon SVG
            html += `<span class="divider"></span>
              <button class="act-btn" data-act="copy" data-tip="Copy" title="Copy"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#0b2633" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg></button>
              <button class="act-btn" data-act="share" data-tip="Share" title="Share">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#0b2633" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                      <polyline points="15 3 21 3 21 9"></polyline>
                      <line x1="10" y1="14" x2="21" y2="3"></line>
                  </svg>
              </button>`;
            actions.innerHTML = html;
            div.appendChild(actions);
            const fr = document.createElement('div');
            fr.className = 'feedback-row';
            fr.innerHTML = `
              <input class="feedback-input" type="text" placeholder="Tell us why you disliked this reply to help us improve" value="${meta.feedback ? escapeHtml(meta.feedback) : ''}">
              <div class="feedback-actions">
                <button class="mini-btn send" data-act="sendFeedback">Send</button>
                <button class="mini-btn cancel" data-act="cancelFeedback">Cancel</button>
              </div>
            `;
            if((meta.awaitingFeedback) || tempDisliked) fr.style.display = 'flex';
            div.appendChild(fr);
        }
        return div;
      }

     function renderMessages(scrollToBottom=true){
  messagesEl.innerHTML = '';
  messages.forEach((m, idx)=>{
      const messageEl = createMessageElement(m, idx);
      messagesEl.appendChild(messageEl);

      const codeBlocksToHighlight = messageEl.querySelectorAll('pre code');
      codeBlocksToHighlight.forEach(block => {
          if (block.classList.contains('hljs-enhanced')) {
              hljs.highlightElement(block);
          }
      });

     // --- START: تعديل المحاذاة للرسائل القديمة ---
      const bubble = messageEl.querySelector('.bubble');
      if (bubble && m.content && isRTL(m.content)) {
          bubble.classList.add('rtl-text');
          messageEl.classList.add('msg-rtl'); // <-- هذا هو السطر الجديد
      }
      // --- END: تعديل المحاזהה للرسائل القديمة ---

      requestAnimationFrame(()=> setTimeout(()=> messageEl.classList.add('show'), 20));
  });
  if(scrollToBottom) messagesEl.scrollTop = messagesEl.scrollHeight;
}
      
      function appendMessage(m, idx) {
        const messageEl = createMessageElement(m, idx);
        messagesEl.appendChild(messageEl);
        requestAnimationFrame(()=> setTimeout(()=> messageEl.classList.add('show'), 20));
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      let currentIndicator = null;
let indicatorTimers = [];

function clearIndicator() {
    indicatorTimers.forEach(id => clearTimeout(id));
    indicatorTimers = [];
    const indicator = messagesEl.querySelector('.typing-indicator');
    if (indicator) {
        indicator.remove();
    }
    currentIndicator = null;
}

function setToAnalyzing(indicator) {
  if (!indicator) return;
  const content = indicator.querySelector('.content');
  if (!content) return;

  const analyzingLayer = indicator.querySelector('.analyzingLayer');
  const path = indicator.querySelector('.led-path');

  // تحديث نص Analyzing حسب نوع المؤشر
  const type = indicator.dataset.indicatorType;
  const txtEl = indicator.querySelector('.analyzingText');
  if (txtEl) {
    if (type === 'image') txtEl.textContent = 'Analyzing image';
    else if (type === 'file') txtEl.textContent = 'Analyzing file';
    else txtEl.textContent = 'Analyzing';
  }

  // إذا المسار لم يُقاس بعد: قياس سريع كـ fallback
  if (path && !path.dataset.measured && typeof path.getTotalLength === 'function') {
    try {
      analyzingLayer.style.transition = 'none';
      analyzingLayer.style.opacity = '1';
      analyzingLayer.style.position = 'absolute';
      analyzingLayer.style.left = '-9999px';

      const pathLen = Math.round(path.getTotalLength());
      path.style.setProperty('--pathLen', pathLen);
      path.style.strokeDasharray = `8 ${pathLen}`;
      path.style.strokeDashoffset = pathLen;
      path.dataset.measured = '1';
      path.dataset.pathLen = String(pathLen);
    } catch (e) {
      console.warn('setToAnalyzing fallback measurement failed', e);
    } finally {
      analyzingLayer.style.transition = '';
      analyzingLayer.style.opacity = '';
      analyzingLayer.style.position = '';
      analyzingLayer.style.left = '';
    }
  }

  // أخيراً: تشغيل التحول CSS
  requestAnimationFrame(() => {
    content.classList.add('to-analyzing');
    if (analyzingLayer) analyzingLayer.setAttribute('aria-hidden', 'false');
  });
}

     // Typing indicator (supports text like "Analyzing file..." or "Analyzing image...")
function showTyping(type = "default") {
  clearIndicator();

  const msg = document.createElement('div');
  msg.className = 'msg assistant typing-indicator show';
  msg.dataset.indicatorType = type;

  const content = document.createElement('div');
  content.className = 'content typing';
  const inner = document.createElement('div');
  inner.className = 'indicatorInner';

  const barsLayer = document.createElement('div');
  barsLayer.className = 'barsLayer';
  barsLayer.innerHTML = `
    <div class="bars">
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
    </div>`;

  let analyzingLabel = 'Analyzing';
  if (type === 'image') analyzingLabel = 'Analyzing image';
  else if (type === 'file') analyzingLabel = 'Analyzing file';

  const analyzingLayer = document.createElement('div');
analyzingLayer.className = 'analyzingLayer';
analyzingLayer.innerHTML = `
  <span class="analyzingText">${analyzingLabel}</span>
`;

// أضف الـ layers بشكل صحيح
inner.appendChild(barsLayer);
inner.appendChild(analyzingLayer);
content.appendChild(inner);
msg.appendChild(content);

  const container =
    (typeof messagesEl !== "undefined" && messagesEl)
      ? messagesEl
      : document.querySelector(".messages") || document.body;

  container.appendChild(msg);

  if (typeof scrollToBottom === "function") {
    try { scrollToBottom(); } catch(e) {}
  } else {
    try { container.scrollTop = container.scrollHeight; } catch (e) {}
  }

  // 🟢 الجديد: نُرجع العنصر
  return msg;
}
      // Safe fallback for simulatedAssistantReply if not defined elsewhere
      function simulatedAssistantReply(text){
        try {
          text = String(text || '').trim();
          if(!text) return '...';
          return 'Assistant (offline): ' + (text.length > 240 ? text.slice(0,240) + '…' : text);
        } catch(e) {
          return 'Assistant (offline)';
        }
      }
async function sendMessage(text, parentIndex = null) {
    let textToUse = (text || '').trim();
    if (!textToUse && !pendingAttachment) return;

    if (pendingAttachment) {
        sendAttachmentNow();
        return;
    }

    const userMessage = { id: genId(), role: 'user', content: textToUse, parent: parentIndex, meta: {} };
    messages.push(userMessage);
    appendMessage(userMessage, messages.length - 1);
    saveSession();
    localStorage.removeItem(DRAFT_KEY);
    updateWelcomeVisibility();
    postMessageToServer(userMessage).catch((err) => {
        console.warn('postMessageToServer failed (will retry):', err);
        scheduleSync();
    });

    clearIndicator();
    showTyping(); 

    let assistantEl = null;
    let bubbleEl = null;
    let assistantMessage = null;
    let isFirstChunk = true;

    try {
        const response = await puter.ai.chat(buildChatPrompt(messages), { model: 'gpt-5-nano', stream: true });

        // --- START: Smart Update Logic ---
        let contentBuffer = ''; // مخزن مؤقت للنص
        let updateInterval = null; // المؤقت الزمني

        const updateUI = () => {
            if (bubbleEl) {
                bubbleEl.innerHTML = DOMPurify.sanitize(marked.parse(assistantMessage.content));
                enhanceCodeBlocks(bubbleEl);
                const isUserAtBottom = messagesEl.scrollHeight - messagesEl.clientHeight <= messagesEl.scrollTop + 20;
                if (isUserAtBottom) {
                    messagesEl.scrollTop = messagesEl.scrollHeight;
                }
            }
        };
        // --- END: Smart Update Logic ---

        for await (const part of response) {
            const piece = part.text || (part.message && part.message.content) || '';
            if (!piece) continue;

           if (isFirstChunk) {
    clearIndicator();
    assistantMessage = { id: genId(), role: 'assistant', content: '', parent: messages.length - 1, meta: {} };
    messages.push(assistantMessage);
    assistantEl = createMessageElement(assistantMessage, messages.length - 1);
    messagesEl.appendChild(assistantEl);
    requestAnimationFrame(() => setTimeout(() => assistantEl.classList.add('show'), 20));
    bubbleEl = assistantEl.querySelector('.bubble');
    isFirstChunk = false;

    // ابدأ المؤقت الزمني للتحديث كل 150ms
    updateInterval = setInterval(updateUI, 150);

    // --- new: حوّل زر الإرسال إلى حالة generating (أزرق) + أرفق stop handler ---
    try {
      const btn = document.getElementById('sendInsideBtn');
      if (btn) {
        // إزالة pending (الرمادي) وإظهار حالة التوليد
        btn.classList.remove('is-pending');
        btn.classList.add('is-generating', 'visible');
        btn.disabled = false;

        // خزّن مرجع response حتى نتمكن من محاولة إيقافه
        btn._abortCurrentResponse = response;

        if (!btn._stopHandler) {
          btn._stopHandler = function(ev) {
            ev.stopPropagation();
            // علامة محلية لإخبار الحلقة بالتوقف فوراً
            window._userRequestedStop = true;
            try {
              if (btn._abortCurrentResponse && typeof btn._abortCurrentResponse.return === 'function') {
                btn._abortCurrentResponse.return(); // حاول إغلاق الـ iterator إن أمكن
              }
            } catch (e) { /* ignore */ }
            // بصمة بصرية سريعة
            btn.classList.add('stopping');
            setTimeout(()=> btn.classList.remove('stopping'), 160);
          };
          btn.addEventListener('click', btn._stopHandler);
        }
      }
    } catch(e) { console.warn('send-button state error', e); }
}

            assistantMessage.content += piece;
        }

        // --- بعد انتهاء الرد بالكامل ---
        clearInterval(updateInterval); // أوقف المؤقت
        updateUI(); // قم بالتحديث الأخير لضمان عرض كل النص
          // --- تنظيف حالة الزر بعد انتهاء الـ stream ---
    try {
      const btn = document.getElementById('sendInsideBtn');
      if (btn) {
        btn.classList.remove('is-generating', 'is-pending');
        btn.disabled = false;
        if (btn._stopHandler) {
          btn.removeEventListener('click', btn._stopHandler);
          btn._stopHandler = null;
        }
        btn._abortCurrentResponse = null;
      }
    } catch(e){}

        if (assistantEl) {
            const codeBlocksToHighlight = assistantEl.querySelectorAll('pre code');
            codeBlocksToHighlight.forEach(block => { hljs.highlightElement(block); });
            const finalBubble = assistantEl.querySelector('.bubble');
            if (finalBubble && isRTL(assistantMessage.content)) {
                finalBubble.classList.add('rtl-text');
                assistantEl.classList.add('msg-rtl');
            }
        }
        saveSession();

    } catch (error) {
        console.error("Puter.js Error:", error);
        clearIndicator();
        const errorMsg = { id: genId(), role: 'assistant', content: 'عذرًا، حدث خطأ ما.', meta: {} };
        appendMessage(errorMsg, messages.length);
    }
}
      

// Regenerate assistant reply for a given parent message index
async function regenerateAssistantForParent(parentIdx){
    try {
        if (window._regenLock) return;
        window._regenLock = true;

        if (typeof parentIdx !== 'number' || !messages[parentIdx]) {
            window._regenLock = false;
            return;
        }
        
        const parentMessage = messages[parentIdx];
        const attachment = parentMessage?.attachment;
        let imageUrl = null;
        let attachmentType = 'default'; // النوع الافتراضي

        // 1. تحقق من وجود ونوع المرفق
        if (attachment && attachment.url) {
            if (attachment.mime_type?.startsWith('image/')) {
                imageUrl = attachment.url;
                attachmentType = 'image';
            } else {
                attachmentType = 'file'; // أي نوع آخر هو "ملف"
            }
        }

        shouldStopGeneration = false;
        sendInsideBtn.classList.add('is-generating');
        sendInsideBtn.classList.add('visible');

        // 2. أظهر الأنيميشن المناسب بناءً على نوع المرفق
        clearIndicator();
        showTyping(attachmentType);

        let assistantEl = null;
        let bubbleEl = null;
        let assistantMessage = null;
        let isFirstChunk = true;

        // 3. استدعاء الذكاء الاصطناعي (فقط الصور يتم إرسالها للتحليل البصري)
        let response;
        const prompt = buildChatPrompt(messages, parentIdx);
        if (imageUrl) {
            // إذا كانت هناك صورة، أرسل النص والصورة معًا
            response = await puter.ai.chat(prompt, imageUrl, { model: 'gpt-5-nano', stream: true });
        } else {
            // للملفات الأخرى والنصوص، أرسل النص فقط (السياق موجود فيه)
            response = await puter.ai.chat(prompt, { model: 'gpt-5-nano', stream: true });
        }
        
        // ... (بقية الدالة لمعالجة الرد التدريجي تبقى كما هي تمامًا) ...
        let updateInterval = setInterval(() => {
            if (bubbleEl) {
                bubbleEl.innerHTML = DOMPurify.sanitize(marked.parse(assistantMessage.content));
                enhanceCodeBlocks(bubbleEl);
                const isUserAtBottom = messagesEl.scrollHeight - messagesEl.clientHeight <= messagesEl.scrollTop + 20;
                if (isUserAtBottom) {
                    messagesEl.scrollTop = messagesEl.scrollHeight;
                }
            }
        }, 150);

        for await (const part of response) {
            if (shouldStopGeneration) { break; }
            const piece = part.text || (part.message && part.message.content) || '';
            if (!piece) continue;

            if (isFirstChunk) {
                clearIndicator();
                assistantMessage = { id: genId(), role: 'assistant', content: '', parent: parentIdx, meta: {} };
                messages.push(assistantMessage);
                assistantEl = createMessageElement(assistantMessage, messages.length - 1);
                messagesEl.appendChild(assistantEl);
                requestAnimationFrame(() => setTimeout(() => assistantEl.classList.add('show'), 20));
                bubbleEl = assistantEl.querySelector('.bubble');
                isFirstChunk = false;
            }
            assistantMessage.content += piece;
        }
        
        clearInterval(updateInterval);
        if (bubbleEl) {
            bubbleEl.innerHTML = DOMPurify.sanitize(marked.parse(assistantMessage.content));
            enhanceCodeBlocks(bubbleEl);
        }

        if (assistantEl) {
            const codeBlocksToHighlight = assistantEl.querySelectorAll('pre code');
            codeBlocksToHighlight.forEach(block => { hljs.highlightElement(block); });
            const finalBubble = assistantEl.querySelector('.bubble');
            if (finalBubble && isRTL(assistantMessage.content)) {
                finalBubble.classList.add('rtl-text');
                assistantEl.classList.add('msg-rtl');
            }
        }
        saveSession();

    } catch (error) {
        console.error("regenerateAssistantForParent Error:", error);
        clearIndicator();
        const errorMsg = { id: genId(), role: 'assistant', content: 'حدث خطأ. يرجى المحاولة مرة أخرى.', meta: {} };
        appendMessage(errorMsg, messages.length);
    } finally {
        sendInsideBtn.classList.remove('is-generating');
        if (composer.value.trim().length === 0) {
            sendInsideBtn.classList.remove('visible');
        }
        window._regenLock = false;
    }
}
// OPEN/CLOSE CHAT (use history for back-button order)
      function openChatSimple(){
        try {
          if(!(history.state && history.state.ui === 'chat')){
            history.pushState({ui:'chat'}, '');
          }
        } catch(e){}
        chatPanel.classList.add('show'); chatPanel.setAttribute('aria-hidden','false');
        setTimeout(()=> { updateComposerSpacing(); messagesEl.scrollTop = messagesEl.scrollHeight; updateWelcomeVisibility(); }, 250);
      }
      function closeChatSimple(){ chatPanel.classList.remove('show'); chatPanel.setAttribute('aria-hidden','true'); if(document.activeElement) document.activeElement.blur(); }

      document.getElementById('openChatBtn')?.addEventListener('click', (e)=>{ e.preventDefault(); openChatSimple(); });

      // back button
      backBtn && backBtn.addEventListener('click', ()=>{ try { history.back(); } catch(e){ closeChatSimple(); } });

      const MAX_VISIBLE_LINES = 4;
      function computeLineHeight(el){
        const cs = window.getComputedStyle(el);
        let lh = parseFloat(cs.lineHeight);
        if(!lh || isNaN(lh)){
          const tmp = document.createElement('div');
          tmp.style.position = 'absolute';
          tmp.style.visibility = 'hidden';
          tmp.style.whiteSpace = 'nowrap';
          tmp.style.font = cs.font;
          tmp.textContent = 'A';
          document.body.appendChild(tmp);
          lh = tmp.getBoundingClientRect().height;
          tmp.remove();
        }
        return Math.max(14, Math.round(lh));
      }
      const LINE_H = computeLineHeight(composer);
      const PADDING_VERT = 24;
      const MIN_HEIGHT = LINE_H + 6;
      const MAX_VISIBLE_HEIGHT = (LINE_H * MAX_VISIBLE_LINES) + PADDING_VERT;
      composer.style.height = Math.max(MIN_HEIGHT, 40) + 'px';
      composer.style.overflowY = 'hidden';

      function autoGrowTextarea(){
        if(!composer) return;
        composer.style.height = 'auto';
        const sh = composer.scrollHeight;
        if(composer.value.trim().length === 0){
          composer.style.height = Math.max(MIN_HEIGHT, 40) + 'px';
          composer.style.overflowY = 'hidden';
        } else if(sh <= MAX_VISIBLE_HEIGHT){
          composer.style.height = Math.max(MIN_HEIGHT, sh) + 'px';
          composer.style.overflowY = 'hidden';
        } else {
          composer.style.height = MAX_VISIBLE_HEIGHT + 'px';
          composer.style.overflowY = 'auto';
          composer.scrollTop = composer.scrollHeight;
        }
        updateComposerSpacing();
        saveDraft();
      }

      function updateSendVisibility(){
        const val = (composer.value || '').trim();
        if(val.length > 0 || pendingAttachment) sendInsideBtn.classList.add('visible');
        else sendInsideBtn.classList.remove('visible');
      }

      composer.addEventListener('input', (e) => {
        updateSendVisibility();
        autoGrowTextarea();
        if (composer.value.trim().length > 0) {
          stopRotator();
        } else {
          startRotatorIfNeeded();
        }
      });
      composer.addEventListener('focus', () => {
        updateSendVisibility();
        autoGrowTextarea();
        startRotatorIfNeeded();
        setTimeout(() => {
            composer.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 150);
      });
      composer.addEventListener('blur', () => {
        updateSendVisibility();
        saveDraft();
        startRotatorIfNeeded();
      });

      sendInsideBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  const t = composer.value.trim();
  if(!t && !pendingAttachment) return;

  // --- new: immediately show pending (رمادي، غير قابل للضغط) ---
  sendInsideBtn.classList.add('is-pending', 'visible');
  sendInsideBtn.disabled = true;

  sendInsideBtn.classList.add('sending');
        setTimeout(()=>{
          sendInsideBtn.classList.remove('sending');
        // ====== START: replace existing "edit" branch with this block ======
if (editIndex !== null && editIndex >= 0) {
  const t = composer.value.trim();

  // 1) تحديث بيانات الرسالة (نحتفظ بأي مرفقات موجودة)
  messages[editIndex].content = t;

  // 2) تحديث فقاعـة الرسالة في الـ DOM من دون مسح الـ children (صور أو مرفقات)
  const editedMsgEl = messagesEl.querySelector(`.msg[data-index="${editIndex}"] .bubble`);
  if (editedMsgEl) {
    // حاول إيجاد عنصر يحمل النص (أفضل إذا كان class="bubble-text")
    let textHolder = editedMsgEl.querySelector('.bubble-text');

    // إذا لم يوجد عنصر مخصص، نبحث عن عقدة نص أو عنصر غير وسائط (IMG/VIDEO/PICTURE)
    if (!textHolder) {
      for (let node of editedMsgEl.childNodes) {
        if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== '') {
          textHolder = node;
          break;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          const tag = node.tagName.toUpperCase();
          // تجاهل عناصر الوسائط و أزرار التحكم داخل الفقاعة
          if (tag !== 'IMG' && tag !== 'PICTURE' && tag !== 'VIDEO'
              && !node.classList.contains('msg-actions') && !node.classList.contains('feedback-row')) {
            textHolder = node;
            break;
          }
        }
      }
    }

    // إذا وجدنا مكاناً للنص، نحدّثه (نستبدل، لا نضيف)
    if (textHolder) {
      if (textHolder.nodeType === Node.TEXT_NODE) {
        textHolder.nodeValue = t;
      } else {
        textHolder.textContent = t;
      }
    } else {
      // لا يوجد نص سابق: نُنشئ span مخصص وندرجه قبل أول ميديا إن وُجدت أو كبداية الفقاعة
      const span = document.createElement('span');
      span.className = 'bubble-text';
      span.textContent = t;
      const media = editedMsgEl.querySelector('img, picture, video');
      if (media) editedMsgEl.insertBefore(span, media);
      else editedMsgEl.insertBefore(span, editedMsgEl.firstChild);
    }
  }

  // 3) حذف الردود التالية من المصفوفة
  messages.splice(editIndex + 1);

  // 4) حذف عناصر DOM المقابلة للرسائل التي بعد الرسالة المعدلة بسلاسة (بدون ومضة)
  const nodes = [...messagesEl.querySelectorAll('.msg')];
  const toRemove = [];
  for (const el of nodes) {
    const i = Number(el.dataset.index || -1);
    if (i > editIndex) toRemove.push(el);
  }
  toRemove.forEach((el, idx) => {
    el.style.transition = 'opacity .12s ease, transform .12s ease';
    el.style.opacity = '0';
    el.style.transform = 'translateY(-6px)';
    setTimeout(() => { el.remove(); }, 120 + idx * 10);
  });

  // 4b) إعادة ترقيم DOM إن وجدت دالة لهذا الغرض
  if (typeof reindexDom === 'function') {
    setTimeout(() => { reindexDom(); }, 160);
  }

  // 5) حفظ الحالة
  saveSession();

  // 6) تنظيف حالة التعديل في الواجهة
  const oldIndex = editIndex;
  editIndex = null;
  editCancelBtn.style.display = 'none';
  composer.value = '';
  localStorage.removeItem(DRAFT_KEY);
  updateSendVisibility();
  autoGrowTextarea();

  // 7) إظهار نقاط الكتابة ثم إضافة رد المساعد الجديد بسلاسة (appendMessage إن وُجد)
    // regenerate reply for edited message
  regenerateAssistantForParent(oldIndex);
  if (typeof reindexDom === 'function') reindexDom();
  return;
}
// ====== END: edit branch replacement ======
 else {
  if (pendingAttachment) {
    sendAttachmentNow();
  } else {
    composer.value = '';
    updateSendVisibility();
    autoGrowTextarea();
    sendMessage(t);
  }
}
startRotatorIfNeeded();

        }, 260);
      });

      composer.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendInsideBtn.click(); } });

      editCancelBtn.addEventListener('click', (e)=>{
        editIndex = null;
        editCancelBtn.style.display = 'none';
        composer.value = '';
        updateSendVisibility();
        autoGrowTextarea();
        saveDraft();
      });

      const composerContainer = document.querySelector('.composer');
      function updateComposerSpacing(){
        if(!composerContainer) return;
        const h = Math.ceil(composerContainer.getBoundingClientRect().height);
        let extra = 0;
        try{
          if (filePreviewContainer && filePreviewContainer.getAttribute('aria-hidden') !== 'true') {
            extra = Math.ceil(filePreviewContainer.getBoundingClientRect().height) + 6;
          }
        }catch(e){}
        messagesEl.style.paddingBottom = (h + 8 + extra) + 'px';
      }
      
      window.addEventListener('resize', updateComposerSpacing);
      setTimeout(()=>{ updateComposerSpacing(); autoGrowTextarea(); }, 120);

      // ========== FIX FOR AUTO-SCROLL WHEN INTERACTING WITH OLD MESSAGES ==========
      let autoScrollEnabled = true;
      const SCROLL_THRESHOLD = 80;
      if (messagesEl) {
        messagesEl.addEventListener('scroll', () => {
          try {
            autoScrollEnabled = (messagesEl.scrollHeight - messagesEl.clientHeight - messagesEl.scrollTop) <= SCROLL_THRESHOLD;
          } catch (e) {}
        });
      }
      const observer = new MutationObserver((mutationsList) => {
        if (chatPanel.classList.contains('show') && autoScrollEnabled) {
          setTimeout(() => { messagesEl.scrollTop = messagesEl.scrollHeight; }, 60);
        }
      });
      observer.observe(messagesEl, {childList:true, subtree:true});
      // ==========================================================================

     // initial load
      loadHistory();
      newConversation(); // <-- يبدأ محادثة جديدة مباشرة
      renderMessages(false); // يعرض الصفحة الفارغة
      updateWelcomeVisibility();
      loadDraft();
      // لا نحتاج persistCurrentToHistory() عند البداية لأن المحادثة فارغة

      // MODIFICATION: New logic for user actions (edit/delete)
      messagesEl.addEventListener('click', (e) => {
        try {
            if (e.target.closest('button, [data-act]')) return;
            const msgEl = e.target.closest('.msg.user');
            if (!msgEl) return;

            if (userActionsTimeout) clearTimeout(userActionsTimeout);

            document.querySelectorAll('.msg.user.show-actions').forEach(el => {
                if (el !== msgEl) el.classList.remove('show-actions');
            });

            msgEl.classList.add('show-actions');

            userActionsTimeout = setTimeout(() => {
                msgEl.classList.remove('show-actions');
            }, 3000);

        } catch (err) {}
      });

      // close any open user action panels when clicking elsewhere
      document.addEventListener('pointerdown', (e) => {
        try {
          if (!e.target.closest('.msg.user')) {
            document.querySelectorAll('.msg.user.show-actions').forEach(el => el.classList.remove('show-actions'));
            if (userActionsTimeout) clearTimeout(userActionsTimeout);
          }
        } catch (err) {}
      });

      // delegate click events inside messages (reactions, regen, like, image open, etc.)
      messagesEl.addEventListener('click', async (e)=>{
        const img = e.target.closest('.att-image');
        if(img){
          openImageLightbox(img.src, img.alt);
          return;
        }

        const el = e.target.closest('button, [data-act]');
        if(!el) return;
        const act = el.dataset.act;
        const container = el.closest('.msg');
        if(!container) return;
        const idx = Number(container.dataset.index);
        if(idx < 0 || !messages[idx]) return;
        let msg = messages[idx];
        
        const updateThisMessage = () => {
            const newMsgEl = createMessageElement(msg, idx);
            container.replaceWith(newMsgEl);
            requestAnimationFrame(() => setTimeout(() => newMsgEl.classList.add('show'), 20));
        };

        if(act === 'copy'){
          try{ 
            const ok = await copyTextToClipboard(msg.content || '');
            if(ok) toast('Copied');
            else toast('Copy not available');
          }catch(err){ toast('Copy not available'); }
        }
        else if(act === 'share'){
          const text = msg.content;
          if(navigator.share){ try{ await navigator.share({ text }); }catch(_e){} }
          else { try{ const ok = await copyTextToClipboard(text); if(ok) toast('Copied for sharing'); else toast('Share not available'); }catch(_e){ toast('Share not available'); } }
        }
        else if (act === 'regen') {
  // لا نعيد رسم الكل: نحذف هذه الفقاعة وما بعدها ثم نُظهر النقاط
  const parentIdx = typeof msg.parent === 'number' ? msg.parent : findPrevUserIndex(idx);
  if (parentIdx === -1) { toast('No related user message'); return; }
  const userText = messages[parentIdx].content;

  // نحافظ على موضع التمرير النسبي
  const prevBottom = messagesEl.scrollHeight - messagesEl.scrollTop;

  // 1) نحذف من البيانات
  messages.splice(idx);

  // 2) نحذف من الـ DOM كل العناصر من هذا الـ index فما بعده
  [...messagesEl.querySelectorAll('.msg')].forEach(n => {
    const i = Number(n.dataset.index || -1);
    if (i >= idx) {
      n.style.transition = 'opacity .12s ease, transform .12s ease';
      n.style.opacity = '0';
      n.style.transform = 'translateY(-2px)';
      setTimeout(() => n.remove(), 120);
    }
  });

  reindexDom(); // مهم: إعادة ترقيم data-index بعد الحذف
  saveSession();

  // 3) نقاط الكتابة
  const typingEl = showTyping();

  regenerateAssistantForParent(parentIdx);


  // 4) استعادة وضع التمرير النسبي
  messagesEl.scrollTop = messagesEl.scrollHeight - prevBottom;
  return;
}

else if (act === 'like') {
  // لا إعادة رسم – فقط تعديل DOM + أنيميشن خفيفة
  msg.meta = msg.meta || {};
  if (msg.meta.locked) return;

  msg.meta.liked = true;
  msg.meta.disliked = false;
  msg.meta.hideDislike = true;
  msg.meta.awaitingFeedback = false;

  // --- أغلق feedback-row إن كان مفتوحاً (علاج المشكلة: Like لا يخفي الحقل) ---
  const fr = container.querySelector('.feedback-row');
  if (fr && fr.style.display !== 'none') {
    fr.style.transition = 'opacity .14s ease, transform .14s ease';
    fr.style.opacity = '0';
    fr.style.transform = 'translateY(-2px)';
    setTimeout(() => { fr.style.display = 'none'; }, 150);
  }

  // أوقف حالة الديسلايك المؤقتة
  msg.meta.tempDisliked = false;

  saveSession();

  const actions = container.querySelector('.msg-actions');
  const likeBtn = actions?.querySelector('[data-act="like"]');
  const dislikeBtn = actions?.querySelector('[data-act="dislike"]');

  // تفعيل اللايك + نبضة صغيرة + لون أزرق
  if (likeBtn) {
    likeBtn.setAttribute('data-active', 'true');
    const svg = likeBtn.querySelector('svg');
    if (svg) {
      svg.setAttribute('stroke', '#0078ff');
      svg.setAttribute('fill', '#0078ff');
    }
    likeBtn.style.transition = 'transform .12s ease, opacity .12s ease';
    likeBtn.style.transform = 'scale(1.08)';
    setTimeout(() => { if (likeBtn) likeBtn.style.transform = 'scale(1)'; }, 140);
  }

  // إخفاء الديسلايك بسلاسة
  if (dislikeBtn) {
    dislikeBtn.style.transition = 'opacity .14s ease, transform .14s ease';
    dislikeBtn.style.opacity = '0';
    dislikeBtn.style.transform = 'translateY(-2px)';
    setTimeout(() => dislikeBtn.remove(), 150);
  }
  return;
}

else if (act === 'dislike') {
  // إظهار/إخفاء حقل الإبلاغ بسلاسة بدون إعادة رسم
  msg.meta = msg.meta || {};
  if (msg.meta.locked) return;

  msg.meta.tempDisliked = !msg.meta.tempDisliked;
  msg.meta.awaitingFeedback = msg.meta.tempDisliked;
  saveSession();

  const dislikeBtn = container.querySelector('[data-act="dislike"]');
  if (dislikeBtn) {
    const svg = dislikeBtn.querySelector('svg');
    if (msg.meta.tempDisliked) {
      dislikeBtn.setAttribute('data-active', 'true');
      if (svg) {
        svg.setAttribute('stroke', '#ff4d4f');
        svg.setAttribute('fill', '#ff4d4f');
      }
    } else {
      dislikeBtn.removeAttribute('data-active');
      if (svg) {
        svg.setAttribute('stroke', '#0b2633');
        svg.setAttribute('fill', 'none');
      }
    }
  }

  const fr = container.querySelector('.feedback-row');
  if (!fr) return;

  if (msg.meta.tempDisliked) {
    fr.style.display = 'flex';
    fr.style.opacity = '0';
    fr.style.transform = 'translateY(4px)';
    fr.style.transition = 'opacity .16s ease, transform .16s ease';
    requestAnimationFrame(() => {
      fr.style.opacity = '1';
      fr.style.transform = 'translateY(0)';
    });
  } else {
    fr.style.transition = 'opacity .14s ease, transform .14s ease';
    fr.style.opacity = '0';
    fr.style.transform = 'translateY(-2px)';
    setTimeout(() => { fr.style.display = 'none'; }, 150);
  }
  return;
}

else if (act === 'sendFeedback') {
  // إرسال التقرير: إخفاء الحقل + إبقاء الديسلايك فقط
  const fr = container.querySelector('.feedback-row');
  const input = fr?.querySelector('.feedback-input');
  const val = (input?.value || '').trim();

  msg.meta = msg.meta || {};
  msg.meta.feedback = val;
  msg.meta.awaitingFeedback = false;
  msg.meta.disliked = true;
  msg.meta.tempDisliked = false;
  msg.meta.liked = false;
  msg.meta.locked = true;
  saveSession();

  // إخفاء الحقل بسلاسة
  if (fr) {
    fr.style.transition = 'opacity .14s ease, transform .14s ease';
    fr.style.opacity = '0';
    fr.style.transform = 'translateY(-2px)';
    setTimeout(() => { fr.style.display = 'none'; }, 150);
  }

  // إبقاء الديسلايك فقط
  const actions = container.querySelector('.msg-actions');
  const likeBtn = actions?.querySelector('[data-act="like"]');
  const dislikeBtn = actions?.querySelector('[data-act="dislike"]');

  if (likeBtn) {
    likeBtn.style.transition = 'opacity .14s ease, transform .14s ease';
    likeBtn.style.opacity = '0';
    likeBtn.style.transform = 'translateY(-2px)';
    setTimeout(() => likeBtn.remove(), 150);
  }
  if (dislikeBtn) {
    dislikeBtn.setAttribute('data-active', 'true');
    const svg = dislikeBtn.querySelector('svg');
    if (svg) {
      svg.setAttribute('stroke', '#ff4d4f');
      svg.setAttribute('fill', '#ff4d4f');
    }
  }

 // إرسال بلاغ الرسالة إلى Firestore
  const reportPayload = {
    type: "message_dislike",
    messageContent: msg.content || "",
    messageId: msg.id,
    feedback: val,
    sessionId: currentSessionId,
    timestamp: firebase.firestore.FieldValue.serverTimestamp()
  };

  db.collection("sections").doc("study_assistant").collection("message_reports").add(reportPayload)
  .then(() => {
      toast('Thank you for your report');
  })
  .catch((error) => {
      console.error("Error sending message report: ", error);
      toast('Failed to send report');
  });
  return;
}
  else if (act === 'cancelFeedback') {
  // إغلاق الحقل بنفس انيميشن الفتح
  const fr = container.querySelector('.feedback-row');
  if (fr) {
    fr.style.transition = 'opacity .14s ease, transform .14s ease';
    fr.style.opacity = '0';
    fr.style.transform = 'translateY(-2px)';
    setTimeout(() => { fr.style.display = 'none'; }, 150);
  }

  // إعادة ضبط الحالة في البيانات
  msg.meta = msg.meta || {};
  msg.meta.tempDisliked = false;
  msg.meta.awaitingFeedback = false;
  saveSession();

  // إعادة زر الديسلايك لحالته الأصلية
  const dislikeBtn = container.querySelector('[data-act="dislike"]');
  if (dislikeBtn) {
    dislikeBtn.removeAttribute('data-active');
    const svg = dislikeBtn.querySelector('svg');
    if (svg) {
      svg.setAttribute('stroke', '#0b2633');
      svg.setAttribute('fill', 'none');
    }
  }
  return;
}

        else if(act === 'user-delete'){
          pendingMessageDeleteIndex = idx;
          messageConfirmModal.classList.add('show');
        }
        else if(act === 'user-edit'){
          editIndex = idx;
          composer.value = messages[idx].content;
          updateSendVisibility();
          autoGrowTextarea();
          editCancelBtn.style.display = 'inline-flex';
          composer.focus();
          setTimeout(()=> { messagesEl.scrollTop = messagesEl.scrollHeight; }, 120);
        }
      });

      messageConfirmModal.addEventListener('click', (e)=>{ if(e.target === messageConfirmModal) messageConfirmModal.classList.remove('show'); });
      messageConfirmModal.querySelector('[data-msg-confirm="no"]').addEventListener('click', ()=>{ messageConfirmModal.classList.remove('show'); pendingMessageDeleteIndex = null; });
     messageConfirmModal.querySelector('[data-msg-confirm="yes"]').addEventListener('click', async ()=>{
  try {
    const idx = Number(pendingMessageDeleteIndex);
    if (isNaN(idx)) {
      messageConfirmModal.classList.remove('show');
      return;
    }

    // find a server message id to base the deletion on (remoteId)
    let serverId = null;
    if (messages[idx] && messages[idx].meta && messages[idx].meta.remoteId) {
      serverId = messages[idx].meta.remoteId;
    } else {
      // fallback: try to find the first message after idx that has remoteId
      for (let i = idx; i < messages.length; i++){
        if (messages[i] && messages[i].meta && messages[i].meta.remoteId) {
          serverId = messages[i].meta.remoteId;
          break;
        }
      }
    }

    // remove locally (keep messages before idx)
    messages = messages.slice(0, idx);
    saveSession();
    renderMessages();

    // ask server to delete messages from that serverId onward
    if (serverId && typeof API_BASE !== 'undefined' && API_BASE) {
      const url = API_BASE + '/api/messages/after/' + encodeURIComponent(serverId);
      scheduleDeletionOnServer(url);
    } else {
      console.info('No serverId found for deletion; local only.');
    }
  } catch(err) {
    console.error('message-delete handler error', err);
  } finally {
    try { messageConfirmModal.classList.remove('show'); } catch(_) {}
  }
});

      function findPrevUserIndex(i){
        for(let k=i-1; k>=0; k--){ if(messages[k].role==='user') return k; }
        return -1;
      }
      function reindexDom(){
  const nodes = messagesEl.querySelectorAll('.msg');
  nodes.forEach((el, i) => { el.dataset.index = i; });
}
      function closeMenus(){ closeAttach(); chatMenu.classList.remove('show'); }

      // chat menu button toggles 'show' (CSS handles fade)
      chatMenuBtn.addEventListener('click', (e)=>{ e.stopPropagation(); chatMenu.classList.toggle('show'); });
      document.addEventListener('click', (e)=>{ if(chatMenu.classList.contains('show') && !chatMenu.contains(e.target) && !chatMenuBtn.contains(e.target)) chatMenu.classList.remove('show'); }, true);

      // ---- Export as HTML (readable) ----
      function buildConversationHTML(msgs, docTitle){
        const sanitized = msgs.map(m => ({ role: m.role, content: escapeHtml(m.content || ''), attachment: m.attachment }));
        const rows = sanitized.map(m => {
          let attHtml = '';
          if(m.attachment){
            if(m.attachment.type === 'image'){
              attHtml = `<div style="margin-top:8px;"><img src="${m.attachment.src}" style="max-width:100%; border-radius:8px;" alt="${escapeHtml(m.attachment.name||'image')}"></div>`;
            } else {
              attHtml = `<div style="margin-top:8px; padding:8px; background:#fbfdff; border:1px solid #eef4fb; border-radius:8px;">${escapeHtml(m.attachment.name||'file')}</div>`;
            }
          }
          return `<div style="margin-bottom:14px;"><div style="font-weight:800; color:${m.role==='user'?'#fff':'#0b2633'}; display:inline-block; padding:6px 10px; border-radius:8px; background:${m.role==='user'?'linear-gradient(90deg,#0078ff,#00aaff)':'#eef6ff'}">${m.role==='user'?'You':'Assistant'}</div><div style="margin-top:8px; white-space:pre-wrap; line-height:1.4;">${m.content.replace(/\n/g,'<br>')}</div>${attHtml}</div>`;
        }).join('\n');
        return `<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>${escapeHtml(docTitle || 'Conversation')}</title>
<style>
  body{ font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial; background:#f6f9fc; color:#0b2633; padding:18px; }
  .wrap{ max-width:900px; margin:0 auto; background:#fff; border-radius:12px; box-shadow:0 20px 60px rgba(6,30,60,0.06); padding:18px; }
  h1{ font-size:20px; color:#0078ff; margin:0 0 12px 0; }
  @media (max-width:600px){ body{padding:12px} .wrap{padding:12px} h1{font-size:18px} }
</style>
<style>
/* Auto direction for message bubbles: Arabic will render RTL automatically */
.msg.assistant .bubble, .msg.user .bubble {
  direction: auto;
  unicode-bidi: plaintext;
}
</style>
</head>
<body>
  <div class="wrap">
    <h1>${escapeHtml(docTitle || 'Conversation')}</h1>
    ${rows}
  </div>
</body>
</html>`;
      }

      function exportConversation(){
        try {
          const data = messages || [];
          if(!data || data.length === 0){ toast('Nothing to save'); return; }
          const title = (data && data.length>0) ? (data.find(m=>m.role==='user' && m.content && String(m.content||'').trim()) ? data.find(m=>m.role==='user' && m.content && String(m.content||'').trim()).content.split(/\s+/).slice(0,4).join(' ') : 'Conversation') : 'Conversation';
          const html = buildConversationHTML(data, title);
          const blob = new Blob([html], { type: 'text/html' });
          const a = document.createElement('a');
          const ts = new Date().toISOString().replace(/[:.]/g,'-');
          const filename = `${(title||'conversation').replace(/[^\w\-]+/g,'_')}-${ts}.html`;
          a.href = URL.createObjectURL(blob);
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(()=> { URL.revokeObjectURL(a.href); a.remove(); }, 300);
          toast('Conversation saved to device');
        } catch(e) {
          console.error(e);
          toast('Save failed');
        }
      }

      // chat menu wiring (Download/Report/Delete)
      chatMenu.addEventListener('click', (e)=>{
        const btn = e.target.closest('button'); if(!btn) return;
        const cmd = btn.dataset.cmd;
        chatMenu.classList.remove('show');
        if(cmd === 'delete'){ openConfirm(); }
        else if(cmd === 'report'){ openReport(); }
        else if(cmd === 'save'){ exportConversation(); }
      });

      function openConfirm(){ confirmModal.classList.add('show'); }
      function closeConfirm(){ confirmModal.classList.remove('show'); }
      confirmModal.addEventListener('click', (e)=>{ if(e.target === confirmModal) closeConfirm(); });
      confirmModal.querySelector('[data-confirm="no"]').addEventListener('click', closeConfirm);
      confirmModal.querySelector('[data-confirm="yes"]').addEventListener('click', ()=>{
  try {
    if (currentConversationId) {
      if (typeof API_BASE !== 'undefined' && API_BASE) {
        const url = API_BASE + '/api/conversations/' + encodeURIComponent(currentConversationId);
        scheduleDeletionOnServer(url);
      }
    }

    messages = [];
    saveSession();
    localStorage.removeItem(DRAFT_KEY);
    renderMessages();
    updateWelcomeVisibility();
    closeConfirm();
    toast('Conversation deleted');

    // ✨ أنشئ محادثة جديدة فاضية بعد الحذف
    newConversation();
  } catch(e) {
    console.error('conversation delete error', e);
  }
});
      const reasons = [
        'Violent content','Self-harm','Explicit sexual content','Hate / incitement',
        'Misinformation','Sensitive content','Privacy issue','Other'
      ];
      let selectedReason = null;

      function openReport(){
        reasonListEl.innerHTML = '';
        selectedReason = null;
        reasons.forEach((r, i)=>{
          const item = document.createElement('div');
          item.className = 'reason';
          item.textContent = r;
          item.addEventListener('click', ()=>{
            selectedReason = r;
            reasonListEl.querySelectorAll('.reason').forEach(el=> el.classList.remove('selected'));
            item.classList.add('selected');
            reportModal.querySelector('[data-report="next"]').disabled = false;
          });
          reasonListEl.appendChild(item);
        });
        reportModal.querySelector('[data-report="next"]').disabled = true;
        reportText.value = '';
        reportStep1.style.display = '';
        reportStep2.style.display = 'none';
        reportModal.classList.add('show');
      }
      function closeReport(){ reportModal.classList.remove('show'); }
      reportModal.addEventListener('click', (e)=>{ if(e.target === reportModal) closeReport(); });
      reportModal.querySelector('[data-report="cancel"]').addEventListener('click', closeReport);
      reportModal.querySelector('[data-report="next"]').addEventListener('click', ()=>{
        reportStep1.style.display = 'none';
        reportStep2.style.display = '';
      });
      reportModal.querySelector('[data-report="back"]').addEventListener('click', ()=>{
        reportStep2.style.display = 'none';
        reportStep1.style.display = '';
      });
      reportModal.querySelector('[data-report="send"]').addEventListener('click', async () => {
        const sendBtn = reportModal.querySelector('[data-report="send"]');
        if (sendBtn.disabled) return;
        sendBtn.disabled = true;
        const prevLabel = sendBtn.textContent;
        sendBtn.textContent = 'Sending...';

        // --- هنا يتم إرسال البيانات إلى Firebase (هذا هو الكود الجديد) ---
        const payload = {
          type: 'conversation_report',
          reason: selectedReason,
          details: (reportText.value || '').trim(),
          sessionId: currentSessionId,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        };

        db.collection("sections").doc("study_assistant").collection("conversation_reports").add(payload)
        .then(() => {
            closeReport();
            toast('Report sent, thank you');
        })
        .catch((error) => {
            console.error("Error sending conversation report: ", error);
            toast('Failed to send report');
        });

        // هذا الجزء يتم إضافته لضمان إعادة الزر لحالته الطبيعية
        sendBtn.disabled = false;
        sendBtn.textContent = prevLabel;
      });

      // ===== Rotator logic =====
      const suggestions = [
          "Summarize this paragraph",
          "Explain like I'm five",
          "Create a 5-question quiz",
          "Give a 2-week study plan",
          "Turn this into flashcards",
          "Highlight key formulas",
          "Make bullet-point notes",
          "Give a short definition",
          // + new suggestions (added per request)
          "Convert to mnemonics",
          "List pros and cons",
          "Create step-by-step solution",
          "Extract key dates/events",
          "Translate to simple English",
          "Generate sample problems",
          "Provide memory tips",
          "Outline for an essay",
          "Identify assumptions",
          "Show visual diagram steps",
          "Compare two concepts",
          "Create a study timetable",
          "Explain with an analogy",
          "Give practical examples",
          "List common mistakes"
      ];

      let rotIndex = 0;
      let rotTimeout = null;
      let rotExitTimeout = null;
      let rotRunning = false;

      const VISIBLE_MS = 2400; // how long suggestion stays visible
      const EXIT_MS = 420; // exit animation duration (matches CSS)

      function showRotatorOnce(idx){
          if(!rotator || !rotatorText) return;
          rotatorText.textContent = suggestions[idx] || '';
          rotator.classList.remove('exit');
          requestAnimationFrame(()=>{
              rotator.classList.add('visible');
          });
      }

      function startRotatorIfNeeded(){
          if(!rotator) return;
          if(composer.value && composer.value.trim().length > 0) { stopRotator(); return; }
          if(rotRunning) return;
          rotRunning = true;
          rotator.classList.remove('hidden');
          rotIndex = 0;
          cycleRotator();
      }

      function stopRotator(){
          rotRunning = false;
          if(rotTimeout){ clearTimeout(rotTimeout); rotTimeout = null; }
          if(rotExitTimeout){ clearTimeout(rotExitTimeout); rotExitTimeout = null; }
          if(rotator){
              rotator.classList.add('exit');
              setTimeout(()=> {
                  if(!rotator) return;
                  rotator.classList.remove('visible');
                  rotator.classList.remove('exit');
                  rotator.classList.add('hidden');
              }, 220);
          }
      }

      function cycleRotator(){
          if(!rotRunning) return;
          showRotatorOnce(rotIndex % suggestions.length);
          rotTimeout = setTimeout(()=>{
              if(rotator) rotator.classList.add('exit');
              rotExitTimeout = setTimeout(()=>{
                  rotIndex++;
                  if(!rotRunning) {
                      if(rotator) { rotator.classList.remove('visible'); rotator.classList.add('hidden'); }
                      return;
                  }
                  if(rotator) {
                      rotator.classList.remove('exit');
                      rotator.classList.remove('visible');
                  }
                  setTimeout(()=>{ if(rotRunning) cycleRotator(); }, 80);
              }, EXIT_MS);
          }, VISIBLE_MS);
      }
      
      openChatBtn?.addEventListener('click', ()=> {
          setTimeout(()=> {
              if(!composer.value || composer.value.trim().length===0) startRotatorIfNeeded();
          }, 300);
      });

      // ===== Welcome banner visibility control (English + fade) =====
      function updateWelcomeVisibility(){
        try{
          const userName = (localStorage.getItem('study_user_name') || '').trim();
          if (userName) {
            welcomeBanner.textContent = `Hi ${userName}, what would you like to learn today?`;
          } else {
            welcomeBanner.textContent = 'Hi, what would you like to learn today?';
          }

          if(messages.length === 0){
            if(!welcomeBanner.classList.contains('visible')){
              welcomeBanner.style.display = '-webkit-box';
              void welcomeBanner.offsetWidth;
              welcomeBanner.classList.remove('hidden');
              welcomeBanner.classList.add('visible');
              welcomeBanner.setAttribute('aria-hidden', 'false');
            }
          } else {
            if(welcomeBanner.classList.contains('visible')){
              welcomeBanner.classList.remove('visible');
              welcomeBanner.classList.add('hidden');
              welcomeBanner.setAttribute('aria-hidden', 'true');
              setTimeout(()=> { try{ welcomeBanner.style.display = 'none'; }catch(e){} }, 400);
            } else {
              welcomeBanner.style.display = 'none';
              welcomeBanner.setAttribute('aria-hidden', 'true');
            }
          }
        } catch(e){}
      }

      // ===== Image Lightbox =====
      function openImageLightbox(src, alt){
        try{
          if(!imageLightboxRoot) return;
          try { if(!(history.state && history.state.ui === 'lightbox')) history.pushState({ui:'lightbox'}, ''); } catch(e){}
          imageLightboxRoot.innerHTML = '';
          imageLightboxRoot.setAttribute('aria-hidden','false');
          const lb = document.createElement('div');
          lb.className = 'img-lightbox';
          lb.innerHTML = `<div class="box"><button class="close-btn" aria-label="Close">×</button><img src="${src}" alt="${escapeHtml(alt||'image')}"></div>`;
          imageLightboxRoot.appendChild(lb);
          lb.querySelector('.close-btn').addEventListener('click', ()=> { try { history.back(); } catch(e){ closeImageLightbox(); } });
          lb.addEventListener('click', (e)=>{
            if(e.target === lb) { try { history.back(); } catch(e){ closeImageLightbox(); } }
          });
        }catch(e){}
      }
      function closeImageLightbox(){
        if(!imageLightboxRoot) return;
        imageLightboxRoot.innerHTML = '';
        imageLightboxRoot.setAttribute('aria-hidden','true');
      }

      // ========== CONVERSATIONS SIDEBAR LOGIC ==========
      function openConvoPanel(){
        if(convoPanel.classList.contains('open')) return;
        convoPanel.classList.add('open');
        convosBtn.classList.add('open');
        convosBtn.setAttribute('aria-expanded','true');
        closeMenus();
        try { history.pushState({ui:'convos'}, ''); } catch(e){}
        convoPanel.setAttribute('aria-hidden','false');
        renderHistoryPanel();
      }
      function closeConvoPanelInternal(){
        convoPanel.classList.remove('open');
        convosBtn.classList.remove('open');
        convosBtn.setAttribute('aria-expanded','false');
        convoPanel.setAttribute('aria-hidden','true');
      }
      function closeConvoPanel(){
        try { history.back(); } catch(e){ closeConvoPanelInternal(); }
      }

      convosBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        if(convoPanel.classList.contains('open')) closeConvoPanel();
        else openConvoPanel();
      });
      convoCloseBtn.addEventListener('click', ()=> closeConvoPanel());

     // click outside to close convoPanel (requirement)
      document.addEventListener('pointerdown', (e)=>{
        try{
          if(convoPanel && convoPanel.classList.contains('open')){
            const ct = e.target;
            // جلب كل العناصر التي لا يجب أن تسبب الإغلاق
            const deleteModal = document.getElementById('deleteSavedModal');
            const convoItemMenu = document.getElementById('convoItemMenu'); // <-- إضافة مهمة جداً

            // الشرط المحدث: لا تغلق القائمة إذا كان الضغط داخل أي من هذه العناصر
            if( !convoPanel.contains(ct) && 
                !convosBtn.contains(ct) && 
                !deleteModal.contains(ct) && 
                !convoItemMenu.contains(ct) ){
              closeConvoPanelInternal();
            }
          }
        }catch(e){}
      });

      // generate title from messages (first user message trimmed to up to 4 words)
      function generateConversationTitle(msgs){
        try{
          if(!Array.isArray(msgs) || msgs.length===0) return 'Conversation';
          const user = msgs.find(m => m.role==='user' && m.content && String(m.content||'').trim());
          if(user){
            const words = user.content.replace(/\s+/g,' ').trim().split(' ').filter(Boolean).slice(0,4);
            if(words.length) return words.join(' ');
          }
          const dt = new Date().toLocaleString();
          return 'Conversation • ' + dt;
        }catch(e){
          return 'Conversation';
        }
      }

     /*
async function syncHistoryFromServer() {
    console.log('Syncing conversation list from server...');
    try {
        const response = await fetch(`${API_BASE}/api/conversations`);
        if (!response.ok) {
            console.warn(`Server sync failed with status: ${response.status}`);
            return;
        }
        const serverConvos = await response.json();
        if (!Array.isArray(serverConvos)) {
            console.warn('Server sync failed: the response was not a list.');
            return;
        }
        savedConvos = serverConvos;
        saveHistory();
        renderHistoryPanel(false);
        console.log('History sync complete.');
    } catch (error) {
        console.warn('Could not sync history from server:', error);
    }
}
*/

      function renderHistoryPanel(){ // تمت إزالة (sync = true)
  loadHistory(); 
  convoChips.innerHTML = '';
  convoList.innerHTML = '';
  if(savedConvos.length === 0){
    const emp = document.createElement('div');
    emp.className = 'convo-item';
    emp.innerHTML = `<div class="left"><div class="title">No saved conversations</div></div>`;
    convoList.appendChild(emp);
    return;
  }

  const chips = savedConvos.slice(0,6);
  chips.forEach((c, i) => {
    const chip = document.createElement('button');
    chip.className = 'convo-chip';
    chip.textContent = c.title || ('Chat ' + (i+1));
    chip.addEventListener('click', ()=> loadSavedConversation(i));
    convoChips.appendChild(chip);
  });

  savedConvos.forEach((c, i) => {
    const it = document.createElement('div');
    it.className = 'convo-item';
    it.dataset.idx = i;
    it.innerHTML = `<div class="left"><div class="title"><span style="margin-left:6px">${escapeHtml(c.title||'Conversation')}</span></div></div><div class="meta">${new Date(c.createdAt||Date.now()).toLocaleString()}</div>`;
    it.addEventListener('click', (ev)=>{
      if(it.dataset._suppressClick === 'true'){ it.dataset._suppressClick = 'false'; return; }
      loadSavedConversation(i);
    });
    attachConvoListItemHandlers(it, i);
    convoList.appendChild(it);
  });

  // تم حذف استدعاء المزامنة من هنا
}
      function attachConvoListItemHandlers(el, idx){
        let longTimer = null;
        const LONG_MS = 600;
        function onLongPress(ev){
          ev.preventDefault();
          showConvoItemMenuAtEvent(ev, idx);
          el.dataset._suppressClick = 'true';
        }
        function clearTimer(){
          if(longTimer){ clearTimeout(longTimer); longTimer = null; }
        }
        el.addEventListener('pointerdown', (e)=>{
          longTimer = setTimeout(()=> onLongPress(e), LONG_MS);
        });
        el.addEventListener('pointerup', (e)=>{
          clearTimer();
        });
        el.addEventListener('pointercancel', clearTimer);
        el.addEventListener('pointerleave', clearTimer);
        el.addEventListener('contextmenu', (ev)=>{
          ev.preventDefault();
          showConvoItemMenuAtEvent(ev, idx);
        });
      }

      function showConvoItemMenuAtEvent(ev, idx){
        const menu = convoItemMenu;
        convoMenuTargetIndex = idx;
        const x = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || 100;
        const y = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || 100;
        menu.style.left = (x + 6) + 'px';
        menu.style.top = (y + 6) + 'px';
        menu.classList.add('show');
        menu.setAttribute('aria-hidden','false');
        setTimeout(()=> {
          const onDoc = (e) => {
            if(!menu.contains(e.target)) {
              menu.classList.remove('show');
              menu.setAttribute('aria-hidden','true');
              document.removeEventListener('pointerdown', onDoc);
            }
          };
          document.addEventListener('pointerdown', onDoc);
        }, 10);
      }

      // --- START: New Rename Logic ---
      const renameModal = document.getElementById('renameModal');
      const renameInput = document.getElementById('renameInput');
      const renameSaveBtn = renameModal.querySelector('[data-rename="save"]');
      const renameCancelBtn = renameModal.querySelector('[data-rename="cancel"]');

      // وظيفة لإظهار نافذة إعادة التسمية
      function openRenameModal(currentIndex) {
        const currentName = savedConvos[currentIndex]?.title || '';
        renameInput.value = currentName;
        renameModal.classList.add('show');
        renameInput.focus();
        renameInput.select();
      }

      // وظيفة لإغلاق النافذة
      function closeRenameModal() {
        renameModal.classList.remove('show');
      }

      // عند الضغط على زر إعادة التسمية في القائمة
      menuRenameBtn.addEventListener('click', () => {
        convoItemMenu.classList.remove('show');
        const idx = convoMenuTargetIndex;
        if (typeof idx === 'number' && savedConvos[idx]) {
          openRenameModal(idx);
        }
      });

      // عند الضغط على زر الإلغاء
      renameCancelBtn.addEventListener('click', closeRenameModal);

      // عند الضغط على زر الحفظ
renameSaveBtn.addEventListener('click', () => {
    const idx = convoMenuTargetIndex;
    if (typeof idx !== 'number' || !savedConvos[idx]) return;

    const newName = renameInput.value.trim();
    if (newName.length > 0) {
      savedConvos[idx].title = newName;
      saveHistory();
      renderHistoryPanel();
      toast('Conversation renamed');
      closeRenameModal();
    } else {
      toast('Name cannot be empty');
    }
  });
      // --- END: New Rename Logic ---

      menuDeleteBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  e.preventDefault();

  try {
    if (convoMenuTargetIndex != null && savedConvos[convoMenuTargetIndex]) {
      const conv = savedConvos[convoMenuTargetIndex];
      pendingDeleteId = conv.id;

      // ✅ هنا: أغلق القائمة الصغيرة فقط
      convoItemMenu.classList.remove('show');

      // ✅ افتح نافذة التأكيد
      deleteSavedModal.classList.add('show');
      deleteSavedModal.dataset.idx = convoMenuTargetIndex;
    }
  } catch (err) {
    console.error('menuDeleteBtn click error', err);
  }
});

      menuLockSoonBtn.addEventListener('click', ()=>{
        convoItemMenu.classList.remove('show');
        // show short note for 3 seconds
        toast('This option will be available soon...', 3000);
      });

      // delete saved modal wiring
      deleteSavedModal.addEventListener('click', (e)=>{ if(e.target === deleteSavedModal) deleteSavedModal.classList.remove('show'); });
      deleteSavedModal.querySelector('[data-delete="no"]').addEventListener('click', ()=> deleteSavedModal.classList.remove('show'));
      deleteSavedModal.querySelector('[data-delete="yes"]').addEventListener('click', ()=>{
  try {
    if (pendingDeleteId) {
      const isDeletingCurrent = currentConversationId === pendingDeleteId;

      // 1. حذف المحادثة من القائمة المحلية ومن الخادم
      savedConvos = savedConvos.filter(c => c.id !== pendingDeleteId);
      saveHistory();
      if (typeof API_BASE !== 'undefined' && API_BASE) {
        const url = API_BASE + '/api/conversations/' + encodeURIComponent(pendingDeleteId);
        scheduleDeletionOnServer(url);
      }
      
      // 2. أغلق نافذة التأكيد وأظهر رسالة
      deleteSavedModal.classList.remove('show');
      toast('Saved conversation deleted');

      if (isDeletingCurrent) {
        // --- الحل النهائي باستخدام setTimeout ---
        // نعطي المتصفح مهلة قصيرة (50 ميلي ثانية) لإنهاء عملية إغلاق النافذة،
        // ثم ننفذ عملية الانتقال إلى صفحة جديدة.
        setTimeout(() => {
          // أ. أولاً وقبل كل شيء، نفرغ الرسائل الحالية من الذاكرة
          messages = [];
          
          // ب. نقوم بإنشاء جلسة جديدة تمامًا
          currentSessionId = 's-' + Math.random().toString(36).slice(2, 9);
          try { localStorage.setItem(CURRENT_ID_KEY, currentSessionId); } catch(e) {}
          
          // ج. نحفظ الحالة الجديدة الفارغة ونحدث الواجهة بالكامل
          saveSession();
          renderMessages();
          updateWelcomeVisibility();
          renderHistoryPanel(); // تحديث القائمة لإزالة العنصر
          
          // د. أغلق القائمة الجانبية
          closeConvoPanel();
        }, 50); // <-- هذا هو مفتاح الحل

      } else {
        // إذا تم حذف محادثة أخرى، فقط حدث القائمة
        renderHistoryPanel();
      }
    }
  } catch(e) {
    console.error('deleteSavedModal error', e);
  } finally {
    pendingDeleteId = null;
  }
});
      // loadSavedConversation (no locking - lock feature removed)
      function loadSavedConversation(idx){
        if(!savedConvos[idx]) return;
        try{
          currentSessionId = savedConvos[idx].id;
          try { localStorage.setItem(CURRENT_ID_KEY, currentSessionId); } catch(e){}
          messages = JSON.parse(JSON.stringify(savedConvos[idx].messages || []));
          saveSession();
          renderMessages();
          updateWelcomeVisibility();
          closeConvoPanelInternal();
          toast('Loaded saved conversation');
        }catch(e){
          console.error(e);
          toast('Unable to load conversation');
        }
      }

      // new chat: save current into history (if not empty), then clear messages and create a new currentSessionId
      newChatBtn.addEventListener('click', ()=>{
        try{
          if(Array.isArray(messages) && messages.length>0){
            const title = generateConversationTitle(messages);
            const conv = { id: genId(), title: title, messages: JSON.parse(JSON.stringify(messages)), createdAt: Date.now() };
            savedConvos.unshift(conv);
            saveHistory();
            toast('Conversation saved');
          }
          currentSessionId = 's-'+Math.random().toString(36).slice(2,9);
          try { localStorage.setItem(CURRENT_ID_KEY, currentSessionId); } catch(e){}
          messages = [];
          saveSession();
          renderMessages();
          updateWelcomeVisibility();
          renderHistoryPanel();
          closeConvoPanel();
        }catch(e){ console.error(e); toast('Could not create new chat'); }
      });
         // --- إضافة: دعم تأثير اللمس لـ New Chat button (place AFTER existing newChatBtn click handler) ---
(function(){
  const newChatBtnEl = document.getElementById('newChatBtn');
  if (!newChatBtnEl) return;

  // touchstart لضمان تفعيل التأثير بصراحة على iOS/Android
  newChatBtnEl.addEventListener('touchstart', (e)=>{
    newChatBtnEl.classList.add('touched');
    // some browsers require a tiny delay to show animation nicely
  }, {passive:true});

  newChatBtnEl.addEventListener('touchend', ()=>{
    // اترك التأثير يشتغل لفترة قصيرة ثم أزل الكلاس
    setTimeout(()=> newChatBtnEl.classList.remove('touched'), 260);
  });

  // تنظيف للماوس/الخروج
  newChatBtnEl.addEventListener('mouseleave', ()=> newChatBtnEl.classList.remove('touched'));
})();

      // update popstate handling to close lightbox -> convoPanel -> chatPanel (ordered)
      window.addEventListener('popstate', (event) => {
        try {
          // If lightbox open, close it first
          if(imageLightboxRoot && imageLightboxRoot.hasChildNodes()){
            closeImageLightbox();
            return;
          }
          // If convo panel open, close
          if(convoPanel && convoPanel.classList.contains('open')){
            closeConvoPanelInternal();
            return;
          }
          // If chat open, close
          if(chatPanel.classList.contains('show')){
            closeChatSimple();
            return;
          }
          // otherwise, allow default browser behavior (e.g., go back to previous page)
        } catch(e){ console.error('popstate handler', e); }
      });

      // area click handlers and keyboard-friendly close for panel
      document.addEventListener('keydown', (e)=>{
        if(e.key === 'Escape'){
          if(imageLightboxRoot && imageLightboxRoot.hasChildNodes()){ closeImageLightbox(); return; }
          if(convoPanel && convoPanel.classList.contains('open')){ closeConvoPanel(); return; }
          if(chatPanel.classList.contains('show')){ closeChatSimple(); return; }
        }
      });

      // ensure history and savedConvos are up-to-date on load
      loadHistory();
      renderHistoryPanel();

      window.__study_chat = { messages, sendMessage, exportConversation, openConvoPanel, closeConvoPanel };

    });
  })();
</script>

<!-- Puter regen/edit integration: delegated handler to support regenerate & edit using sendMessage() -->
<script>
(function(){
  if (window.__puter_regen_edit_installed) return;
  window.__puter_regen_edit_installed = true;

  document.addEventListener('click', async function(e){
    const btn = e.target.closest && e.target.closest('.act-btn');
    if (!btn) return;
    const act = btn.dataset && btn.dataset.act;
    if (!act) return;

    try {
      if (act === 'regen') {
        e.preventDefault();
        // find the assistant message element
        const msgEl = btn.closest('.msg');
        if (!msgEl) return;
        // determine message index or id
        const idx = msgEl.dataset && msgEl.dataset.index ? Number(msgEl.dataset.index) : null;
        let parentIdx = null;
        if (idx !== null && window.messages && window.messages[idx]) {
          parentIdx = window.messages[idx].parent;
        }
        // fallback: find the nearest previous user message
        if (parentIdx == null && Array.isArray(window.messages)) {
          for (let i = (idx || window.messages.length-1); i >= 0; i--) {
            if (window.messages[i] && window.messages[i].role === 'user') { parentIdx = i; break; }
          }
        }
        if (parentIdx == null) return;
        const userMsg = window.messages[parentIdx];
        if (!userMsg) return;

        // Remove assistant replies associated with this parent (so regenerate is clean)
        if (Array.isArray(window.messages)) {
          for (let i = window.messages.length - 1; i > parentIdx; i--) {
            if (window.messages[i] && window.messages[i].role === 'assistant' && window.messages[i].parent === parentIdx) {
              window.messages.splice(i, 1);
            }
          }
        }

        // re-render messages to remove old assistant bubbles if function available
        if (typeof window.renderMessages === 'function') {
          try { window.renderMessages(true); } catch(e) {}
        } else {
          // minimal DOM cleanup: remove assistant msg elements after parentIdx if present
          try {
            const nodes = document.querySelectorAll('.msg');
            for (let i = nodes.length-1; i >=0; i--) {
              const n = nodes[i];
              const di = n.getAttribute('data-index');
              if (di && Number(di) > parentIdx && n.classList.contains('assistant')) n.remove();
            }
          } catch(e) {}
        }

        // show typing and call sendMessage to regenerate
        try {
          // call sendMessage on the user's message content and pass parentIndex
          if (typeof sendMessage === 'function') {
            sendMessage(userMsg.content, parentIdx);
          } else {
            console.warn('sendMessage is not defined');
          }
        } catch(err) {
          console.error('regen handler error', err);
        }
      } else if (act === 'edit') {
        e.preventDefault();
        const msgEl = btn.closest('.msg');
        if (!msgEl) return;
        const idx = msgEl.dataset && msgEl.dataset.index ? Number(msgEl.dataset.index) : null;
        if (idx == null) return;
        const target = (window.messages && window.messages[idx]) ? window.messages[idx] : null;
        if (!target) return;

        // If editing a user message, populate composer and set editIndex for your existing edit flow if present
        if (target.role === 'user') {
          if (typeof window.composer !== 'undefined') {
            composer.value = target.content || '';
            editIndex = idx;
            if (typeof updateSendVisibility === 'function') try{ updateSendVisibility(); }catch(e) {}
            if (typeof autoGrowTextarea === 'function') try{ autoGrowTextarea(); }catch(e) {}
            // focus composer
            try { composer.focus(); } catch(e) {}
          } else {
            // fallback: prompt for new content and resend
            const newText = prompt('Edit message:', target.content || '');
            if (newText !== null) {
              window.messages[idx].content = String(newText);
              // remove assistant replies after this user message
              for (let i = window.messages.length - 1; i > idx; i--) {
                if (window.messages[i] && window.messages[i].role === 'assistant' && window.messages[i].parent === idx) {
                  window.messages.splice(i, 1);
                }
              }
              if (typeof window.saveSession === 'function') try{ saveSession(); }catch(e) {}
              if (typeof window.renderMessages === 'function') try{ renderMessages(true); }catch(e) {}
              // resend using sendMessage
              if (typeof sendMessage === 'function') sendMessage(newText, idx);
            }
          }
        } else {
          // If edit clicked on assistant message, find parent user and open composer for that parent
          const parentIdx = target.parent != null ? target.parent : (function(){ for (let i=idx-1;i>=0;i--) if (window.messages[i] && window.messages[i].role==='user') return i; return null; })();
          if (parentIdx != null) {
            const parentMsg = window.messages[parentIdx];
            if (parentMsg && typeof window.composer !== 'undefined') {
              composer.value = parentMsg.content || '';
              editIndex = parentIdx;
              if (typeof updateSendVisibility === 'function') try{ updateSendVisibility(); }catch(e) {}
              if (typeof autoGrowTextarea === 'function') try{ autoGrowTextarea(); }catch(e) {}
              try { composer.focus(); } catch(e) {}
            }
          }
        }
      }
    } catch(ex) {
      console.error('regen/edit delegated handler error', ex);
    }
  }, true);
})();
</script>
</body>

</html>
